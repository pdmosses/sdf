{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Hyperlinked Twin","text":"<p>This website is a hyperlinked twin of a Spoofax language project code repository. The website navigation hierarchy corresponds to the repository file hierarchy, and the code displayed on each page is a verbatim copy of the raw code in the corresponding file.</p> <p>Hyperlinked twins support precise name-based code navigation online in ordinary web browsers:</p> <ul> <li>Simply click on a name reference to jump to the first declaration of the name.</li> <li>Click on a declaration to display a modal with links to all the references to the declaration.<sup>1</sup></li> </ul> <p>The sources of the webpages were generated using Spoofax from the analysed language project. The hyperlinks added to names were generated from the name binding analysis used by Spoofax, and the syntax highlighting corresponds closely to that displayed when browsing files in Spoofax.</p> <p>The aim is for a future release of Spoofax to support generation of hyperlinked twin websites with code in all Spoofax meta-languages.</p> <ol> <li> <p>When there is only one reference to a declaration, \u200b    clicking on the declaration jumps directly to the reference. \u200b    When there are no references to a declaration, \u200b    clicking on it has no effect.\u00a0\u21a9</p> </li> </ol>"},{"location":"org.metaborg.meta.lang.template/","title":"SDF3 \u2013 Syntax Definition Formalism","text":"<p>SDF3 is the third version of the Syntax Definition Formalism meta-language in Spoofax for defining the syntax of a language, which is used for both parsing an input into an Abstract Syntax Tree (AST), and to provide syntax highlighting.</p> <p>Through the use of templates, SDF3 can also be used to define a pretty-printer.</p> <p>SDF3 was originally called \"The Template Language\".</p>"},{"location":"org.metaborg.meta.lang.template/#syntax","title":"Syntax","text":"<p>TemplateLang.sdf3</p> <p>The syntax of SDF3 is defined in SDF3 itself.</p> <p>This example demonstrates generation of a hyperlinked twin from a bootstrapped meta-language definition.</p>"},{"location":"org.metaborg.meta.lang.template/#name-binding","title":"Name binding","text":"<p><code>names.nab</code></p> <p>The name binding of SDF3 is specified in NaBL for use in Spoofax 2.</p> <p><code>main.stx</code></p> <p>The name binding of SDF3 is specified in Statix for use in Spoofax 3.</p>"},{"location":"org.metaborg.meta.lang.template/src-gen/syntax/permissive-water.sdf3/","title":"<code>permissive-water.sdf3</code>","text":"<pre><code>module permissive-water\n\n// Key idea: WATER is the inverse of LAYOUT\n\ncontext-free syntax\n  // Allow WATER on places where LAYOUT may occur\n  LAYOUT.WATER = WATER\n\nlexical sorts\n  WATER\n  WATERTOKEN\n  WATERTOKENSTART\n  WATERTOKENSEPARATOR\n\nlexical syntax\n  // Separate water regions into smaller chunks for recovery costs calculation\n  WATER = WATERTOKEN\n  WATER = WATERTOKENSEPARATOR\n\n  // Allow to skip over identifier strings\n  WATERTOKEN      = WATERTOKENSTART [A-Za-z0-9\\_]*\n  WATERTOKENSTART = [A-Za-z0-9\\_] {recover}\n\n  // Allow to skip over special characters that are neither part of identifiers nor whitespace characters\n  WATERTOKENSEPARATOR = ~[A-Za-z0-9\\_\\ \\t\\12\\r\\n\\*] {recover}\n\nlexical restrictions\n  WATERTOKEN -/- [A-Za-z0-9\\_]\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/src-gen/syntax/permissive-water.sdf3/#modal-h2","title":"permissive-water.sdf3","text":""},{"location":"org.metaborg.meta.lang.template/syntax/TemplateLang.sdf3/","title":"<code>TemplateLang.sdf3</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/syntax/TemplateLang.sdf3</p> <pre><code>module TemplateLang \nimports\n  sdf2-core/Sdf2\n  constants/StrCon\n  sorts/Sorts\n  symbols/Symbols\n  labels/Labels\n  constants/IdentifierCon\n  kernel/Kernel\n  restrictions/Restrictions\n  priority/Priority\n  basic/Basic\n  modules/Modules\n  layout-constraints/Layout-Constraints\n\ncontext-free start-symbols\n    Module\n\ncontext-free syntax\n//options section\nSection.TemplateOptions = &lt;\n        template options \n\n                &lt;{TemplateOption \"\\n\"}*&gt;\n\n        &gt; \n\nTemplateOption.Newlines = &lt;newlines : &lt;NewlineOptionValue&gt;&gt;\n\nTemplateOption.KeywordAttributes = &lt;&lt;SymbolDef&gt; = keyword &lt;Attributes&gt;&gt;\n\nNewlineOptionValue.None = &lt;none&gt;\nNewlineOptionValue.Leading = &lt;leading&gt;\nNewlineOptionValue.Trailing = &lt;trailing&gt;\nNewlineOptionValue.Separating = &lt;separating&gt;\n\nTemplateOption.KeywordFollowRestriction = &lt;keyword -/- &lt;Lookaheads&gt;&gt;\n\nTemplateOption.Tokenize = &lt;tokenize : &lt;StrCon&gt;&gt;\n\ncontext-free syntax\n//references to productions using sort.cons notation in priority specification\nGroup.SimpleRefGroup = &lt;&lt;SortConsRef&gt;&gt;\nGroup.ProdsRefGroup = &lt;{&lt;{SortConsRef \"\\n\"}+&gt;}&gt;\nGroup.AssocRefGroup = &lt;\n        {&lt;Associativity&gt; :\n                &lt;{SortConsRef \"\\n\"}+&gt;}&gt;\nSortConsRef.SortConsRef = &lt;&lt;Symbol&gt;.&lt;Constructor&gt;&gt;\n\ncontext-free syntax \n//grammars\nSection.TemplateSection = &lt;\n        templates \n\n                &lt;{TemplateProduction \"\\n\"}*&gt;\n\n        &gt; {deprecated(\"Use context-free syntax section instead\")}\n\nGrammar.LexicalSyntax = &lt;\n        lexical syntax \n\n                &lt;{SdfProduction \"\\n\"}*&gt;\n\n        &gt; {prefer}\n\nGrammar.ContextFreeSyntax = &lt;\n        context-free syntax \n\n                &lt;{GeneralProduction \"\\n\"}*&gt;\n\n        &gt; {prefer}\n\nGrammar.Kernel = &lt;\n        syntax \n\n                &lt;{SdfProduction \"\\n\"}*&gt;\n\n        &gt; {prefer}\n\nGeneralProduction = &lt;&lt;SdfProduction&gt;&gt;\nGeneralProduction = &lt;&lt;TemplateProduction&gt;&gt; {prefer}\n\n\n// syntactic sugar for SDF\nSdfProduction.SdfProduction = &lt;&lt;SymbolDef&gt; = &lt;RHS&gt; &lt;Attributes&gt;&gt; \nSdfProduction.SdfProductionWithCons = &lt;&lt;SortCons&gt; = &lt;RHS&gt; &lt;Attributes&gt;&gt;\nRHS.Rhs = &lt;&lt;Symbols&gt;&gt;\n\n// template productions\nTemplateProduction.TemplateProduction = &lt;&lt;SymbolDef&gt; = &lt;Template&gt; &lt;Attributes&gt;&gt;\n\n// template productions Sort.Cons = ...\nTemplateProduction.TemplateProductionWithCons = &lt;&lt;SortCons&gt; = &lt;Template&gt; &lt;Attributes&gt;&gt;\n\nConstructor.Constructor = &lt;&lt;IdCon&gt;&gt;\n\nSortCons.SortCons = &lt;&lt;SymbolDef&gt;.&lt;Constructor&gt;&gt;\n\n\n// placeholders\nTemplatePart1.Angled       = [&lt;[Placeholder]&gt;]\nTemplatePart1.BreakAngled  = [&lt;&gt;]\nTemplatePart2.Squared      = &lt;[&lt;Placeholder&gt;]&gt;\nTemplatePart2.BreakSquared = &lt;[]&gt;\n\nPlaceholder.Placeholder = &lt;&lt;Symbol&gt;&lt;PlaceholderOptions&gt;&gt;\n\n\n\nPlaceholderOptions.NoOptions = &lt;&gt;\nPlaceholderOptions.Options = &lt;;&lt;{PlaceholderOption \", \"}+&gt;&gt;\n\nPlaceholderOption.Hide = &lt;hide&gt;\nPlaceholderOption.Wrap = &lt;wrap&gt;\nPlaceholderOption.Anchor = &lt;anchor&gt;\nPlaceholderOption.Floating = &lt;float&gt;\nPlaceholderOption.CompCursor = &lt;cursor&gt;\n//mark as deprecated\nPlaceholderOption.Separator = &lt;separator=&lt;StrCon&gt;&gt; {deprecated(\"Use list with separator symbol instead: {S \\\"separator\\\"}*\")}\nPlaceholderOption.Text = &lt;text=&lt;StrCon&gt;&gt;\n\n  syntax\n\n\n  Template-CF.Template = \"&lt;\" {TemplateLine1-CF \"\\n\"}+ \"&gt;\"\n  Template-CF.TemplateDeprecated =  \"&lt;&lt;\" {TemplateLine1-CF \"\\n\"}+ \"&gt;&gt;\" {avoid, deprecated(\"Use single brackets to delimit the template\")}\n  TemplateLine1-CF.Line = TemplatePart1-CF* \n  TemplatePart1-CF.String = TemplateString1-LEX\n  TemplatePart1-CF.Escape = TemplateEscape1-LEX\n  TemplatePart1-CF.Layout = TemplateLayout-LEX \n\n  Template-CF.TemplateSquare = \"[\" {TemplateLine2-CF \"\\n\"}+ \"]\"\n  Template-CF.TemplateSquareDeprecated = \"[[\" {TemplateLine2-CF \"\\n\"}+ \"]]\" {avoid, deprecated(\"Use single brackets to delimit the template\")}\n  TemplateLine2-CF.Line = TemplatePart2-CF* \n\n  TemplatePart2-CF.String =  TemplateString2-LEX \n\n  TemplatePart2-CF.Escape = TemplateEscape2-LEX\n  TemplatePart2-CF.Layout = TemplateLayout-LEX\n\n\n  lexical syntax\n\n          EOL = LF\n          EOL = CR\n          EOL = CR LF\n\n          CR = [\\r]\n          LF = [\\n]\n\n    \"\\n\" = EOL\n\n  lexical restrictions\n\n    EOL -/- [\\n]\n\n\n  lexical syntax\n\n    TemplateLayout =  [\\ \\t]+\n\n    TemplateString1 = TemplateString1Alt+\n    TemplateString2 = TemplateString2Alt+\n        TemplateStringQ =  ~[\\\\\\\"\\ \\t]+   \n    TemplateString1Alt = ~[\\\\\\&lt;\\&gt;\\ \\t\\r\\n]\n    TemplateString2Alt = ~[\\\\\\[\\]\\ \\t\\r\\n] \n    TemplateString2Alt = Backslash\n\n        Backslash = [\\\\] \n    // [\\\\] -&gt; Backslash1\n    // [\\\\] -&gt; Backslash2      =&gt; [\\\\] -&gt; Backslash\n\n  lexical restrictions\n    TemplateLayout -/- [\\ \\t]\n\n    %% must be followed by:\n    TemplateString1 -/- ~[\\\\\\&lt;\\&gt;\\ \\t\\r\\n]\n    TemplateString2 -/- ~[\\\\\\[\\]\\ \\t\\r\\n]\n    TemplateStringQ -/- ~[\\\\\\\"\\ \\t]\n\n    %% if followed by a backslash, then the backslash must be followed by:\n    TemplateString1 -/- [\\\\].~[\\&lt;\\&gt;\\\\]\n    TemplateString2 -/- [\\\\].~[\\[\\]\\\\]\n\n    Backslash -/- [\\&lt;\\&gt;\\\\]\n\n  template options\n\n          tokenize : \"=\"  \n\n  lexical syntax\n  //production for ContenteCompletion\n  CONTENTCOMPLETE = [a-zA-Z]* \"CONTENTCOMPLETE\" [0-9]+  {avoid}\n\n  //combine sequences of escaped chars\n  TemplateEscape1 = EscapedChar1+\n  TemplateEscape2 = EscapedChar2+\n\n  //this are the escapes which StringTemplate has\n  EscapedChar1 = \"\\\\&lt;\"\n  EscapedChar1 = \"\\\\&gt;\"\n  EscapedChar1 = \"\\\\\\\\\"\n  EscapedChar2 = \"\\\\[\"\n  EscapedChar2 = \"\\\\]\"\n  EscapedChar2 = \"\\\\\\\\\"\n\n   //EscapedChar1 = \"&lt;\" (EscapedBackslashChar1 | EscapedChar)* \"&gt;\"\n   EscapedChar1 = \"&lt;\" EscapedChar1Alt+ \"&gt;\"\n   EscapedChar1Alt = EscapedBackslashChar1\n   EscapedChar1Alt = EscapedChar\n\n   EscapedChar1 = \"&lt;\\\\\\\\&gt;\" [\\ \\t\\r]* [\\n]\n\n   //EscapedChar2 = \"[\" (EscapedBackslashChar2 | EscapedChar)* \"]\"\n   EscapedChar2 = \"[\" EscapedChar2Alt+ \"]\"\n   EscapedChar2Alt = EscapedBackslashChar2 \n   EscapedChar2Alt = EscapedChar\n   EscapedChar2 = \"[\\\\\\\\]\" [\\ \\t\\r]* [\\n]\n\n    // double-backslash isn't allowed as sole member of escape placeholder\n    // (would clash with &lt;\\\\&gt; / [\\\\] line continuation construct)\n    // so we add follow restrictions to the following symbols:\n   EscapedBackslashChar1 = \"\\\\\\\\\"\n   EscapedBackslashChar2 = \"\\\\\\\\\"\n\n   TemplateEscapeQ = TemplateEscapeQAlt+\n   TemplateEscapeQAlt = EscapedChar\n   TemplateEscapeQAlt = \"\\\\\\\\\"\n\n   //escapes allowed in a placeholder-like construct\n   EscapedChar = \"\\\\'\"\n   EscapedChar = '\\\\\"'\n   EscapedChar =  \"\\\\ \"\n   EscapedChar =  \"\\\\t\"\n   EscapedChar =  \"\\\\r\"\n   EscapedChar =  \"\\\\n\"\n\n\n\n    EscapedUnicodeChar = \"\\\\u\" [0-9A-Fa-f]+ \n    EscapedChar = EscapedUnicodeChar\n\n    EscapedChar.WATER = \"\\\\\" ~[] {recover}\n    EscapedChar1.WATER = \"&lt;\" ~[\\&gt;]+ \"&gt;\" {recover}\n    EscapedChar2.WATER = \"[\" ~[\\]]+ \"]\" {recover}\n\n\n  lexical restrictions\n    TemplateEscape1 -/- [\\\\]\n    TemplateEscape1 -/- [\\&lt;].[\\\\\\&gt;]\n    TemplateEscape2 -/- [\\\\]\n    TemplateEscape2 -/- [\\[].[\\\\\\]]\n    TemplateEscapeQ -/- [\\\\]\n    EscapedBackslashChar1 -/- [\\&gt;]\n    EscapedBackslashChar2 -/- [\\]]\n    EscapedUnicodeChar -/- [0-9A-Fa-f]\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/syntax/TemplateLang.sdf3/#modal-h2","title":"TemplateLang.sdf3","text":""},{"location":"org.metaborg.meta.lang.template/syntax/aliases/Aliases.sdf3/","title":"<code>Aliases.sdf3</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/syntax/aliases/Aliases.sdf3</p> <pre><code>module aliases/Aliases\n\nimports kernel/Kernel\n                symbols/Symbols\n\n//context-free syntax \n\n// HACK: incremental parsing annotation\n// Symbols \"-&gt;\" result:Symbol Attributes -&gt; Production  {cons(\"prod\"), incremental}\n//Production.Prod = &lt;&lt;Symbols&gt; -\\&gt; &lt;result:Symbol&gt; &lt;Attributes&gt; &gt; {incremental}\n\n\ncontext-free syntax  \n\nGrammar.Aliases = &lt;\n        aliases \n\n                &lt;Aliases&gt;\n\n        &gt;\n        //Symbol arrow:\"-&gt;\" alias:Symbol -&gt; Alias    {cons(\"alias\")}\nAlias.Alias = &lt;&lt;Symbol&gt; -\\&gt; &lt;alias:Symbol&gt;&gt;\nAliases     = &lt;&lt;list:Alias*&gt;&gt; \n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/syntax/aliases/Aliases.sdf3/#modal-h2","title":"Aliases.sdf3","text":""},{"location":"org.metaborg.meta.lang.template/syntax/aterms/Aterms.sdf3/","title":"<code>Aterms.sdf3</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/syntax/aterms/Aterms.sdf3</p> <pre><code>module aterms/Aterms\n\nimports constants/IntCon\n                constants/RealCon\n                constants/StrCon\n        constants/IdentifierCon\n\ncontext-free syntax\n        AFun.Quoted = &lt;&lt;StrCon&gt;&gt;\n        AFun.Unquoted = &lt;&lt;IdCon&gt;&gt;\n\n\ncontext-free syntax\n        ATerm.Int = &lt;&lt;IntCon&gt;&gt;\n        ATerm.Real = &lt;&lt;RealCon&gt;&gt;\n        ATerm.Fun = &lt;&lt;AFun&gt;&gt;\n        ATerm.Appl = &lt;&lt;AFun&gt;(&lt;{ATerm \",\"}+&gt;)&gt;\n        ATerm.Placeholder = &lt;\\&lt;&lt;ATerm&gt;\\&gt;&gt;\n        ATerm.List = &lt;[&lt;{ATerm \",\"}*&gt;]&gt;\n        ATerm.Annotated = &lt;&lt;ATerm&gt;&lt;Annotation&gt;&gt;\n\ncontext-free syntax\n        Annotation.Default = &lt;{&lt;{ATerm \",\"}+&gt;}&gt;\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/syntax/aterms/Aterms.sdf3/#modal-h2","title":"Aterms.sdf3","text":""},{"location":"org.metaborg.meta.lang.template/syntax/basic/Basic.sdf3/","title":"<code>Basic.sdf3</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/syntax/basic/Basic.sdf3</p> <pre><code>module basic/Basic\n\nimports kernel/Kernel\n                sorts/Sorts\n                TemplateLang\n\ncontext-free syntax\n\nGrammar.Lexical = &lt;\n        lexical syntax\n\n                &lt;Productions&gt;\n\n        &gt;\nGrammar.Contextfree = &lt;\n        context-free syntax\n\n                &lt;Productions&gt;\n\n        &gt;\nGrammar.Variables = &lt;\n        variables\n\n                &lt;Productions&gt;\n\n        &gt;\nGrammar.VariablesProductive = &lt;\n    variables\n\n            &lt;{SdfProduction \"\\n\"}*&gt;\n\n    &gt;        {prefer}\n\nGrammar.LexVariables = &lt;\n        lexical variables\n\n                &lt;Productions&gt;\n\n        &gt;\n\nGrammar.LexVariablesProductive = &lt;\n    lexical variables\n\n            &lt;{SdfProduction \"\\n\"}*&gt;\n\n    &gt; {prefer}\n\nSymbol.Cf = &lt;&lt;Symbol&gt;-CF&gt;\nSymbol.Lex = &lt;&lt;Symbol&gt;-LEX&gt;\nSymbol.Varsym = &lt;&lt;Symbol&gt;-VAR&gt;\nSymbol.Layout = &lt;LAYOUT&gt;  \n\nlexical syntax\n\nSort = Sort \"-LEX\" {reject}\nSort = Sort \"-CF\" {reject}\nSort = Sort \"-VAR\" {reject}\nSort = \"LAYOUT\" \"-LEX\" {reject}\nSort = \"LAYOUT\" \"-CF\" {reject}\nSort = \"LAYOUT\" \"-VAR\" {reject}\n\n\n\n\n\n\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/syntax/basic/Basic.sdf3/#modal-h2","title":"Basic.sdf3","text":""},{"location":"org.metaborg.meta.lang.template/syntax/characterclass/CC.sdf3/","title":"<code>CC.sdf3</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/syntax/characterclass/CC.sdf3</p> <pre><code>module characterclass/CC\n\nimports characterclass/Character-Class \n        kernel/Kernel\n\ncontext-free syntax\n    Symbol.CharClass = &lt;&lt;CharClass&gt;&gt;\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/syntax/characterclass/CC.sdf3/#modal-h2","title":"CC.sdf3","text":""},{"location":"org.metaborg.meta.lang.template/syntax/characterclass/Character-Class.sdf3/","title":"<code>Character-Class.sdf3</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/syntax/characterclass/Character-Class.sdf3</p> <pre><code>module characterclass/Character-Class\n\nimports characterclass/Character\n\ncontext-free syntax\n\nCharRange = &lt;&lt;Character&gt;&gt;\nCharRange.Range = &lt;&lt;start:Character&gt;-&lt;end:Character&gt;&gt;\nCharRanges = &lt;&lt;CharRange&gt;&gt;\n//\"left\":CharRanges \"right\":CharRanges        -&gt; CharRanges   {cons(\"conc\"),right,memo}\nCharRanges.Conc = &lt;&lt;CharRanges&gt;&lt;CharRanges&gt;&gt; {right, memo}\nCharRanges = &lt;(&lt;CharRanges&gt;)&gt; {bracket}\n\nOptCharRanges.Absent = &lt;&gt;\nOptCharRanges.Present = &lt;&lt;CharRanges&gt;&gt;\n\nCharClass.Simple = &lt;[&lt;OptCharRanges&gt;]&gt;\nCharClass.Comp = &lt;~&lt;CharClass&gt;&gt;\n//\"left\":CharClass \"/\" \"right\":CharClass   -&gt; CharClass  {cons(\"diff\"),left,memo}\nCharClass.Diff = &lt;&lt;CharClass&gt;/&lt;CharClass&gt;&gt; {left, memo}\n//\"left\":CharClass \"/\\\\\" \"right\":CharClass -&gt; CharClass  {cons(\"isect\"),left,memo}\nCharClass.Isect = &lt;&lt;CharClass&gt;/\\\\&lt;CharClass&gt;&gt; {left, memo}\n//\"left\":CharClass \"\\\\/\" \"right\":CharClass -&gt; CharClass  {cons(\"union\"),left}\nCharClass.Union = &lt;&lt;CharClass&gt;\\\\/&lt;CharClass&gt;&gt; {left}\nCharClass = &lt;(&lt;CharClass&gt;)&gt; {bracket, avoid}\n\ncontext-free priorities\n        CharClass.Comp &gt; CharClass.Diff &gt;\n        CharClass.Isect &gt; CharClass.Union\n\n\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/syntax/characterclass/Character-Class.sdf3/#modal-h2","title":"Character-Class.sdf3","text":""},{"location":"org.metaborg.meta.lang.template/syntax/characterclass/Character.sdf3/","title":"<code>Character.sdf3</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/syntax/characterclass/Character.sdf3</p> <pre><code>module characterclass/Character\n\nlexical syntax\n    RegularChar = character:[a-zA-Z0-9]\n    EscapedChar = escape:(~[\\0-\\31A-Za-z0-9] \\/ [fnrtv])\n    BinChar = number:[01]+\n    OctChar = number:[0-7]+\n    NumChar = number:Zero\n    NumChar = number:([1-9] [0-9]*)\n    HexChar = number:[0-9A-Fa-f]+\n    Zero = \"0\"\n\nlexical restrictions\n    BinChar -/- [0-1]\n    OctChar -/- [0-7]\n    NumChar -/- [0-9]\n    HexChar -/- [0-9A-Fa-f]\n\n    Zero -/- [0bx] // To avoid clashes with Binary, Octal, and Hexadecimal\n\nsyntax\n    Character-CF.Regular = RegularChar-LEX\n    Character-CF.Escaped = \"\\\\\" EscapedChar-LEX\n    Character-CF.Binary = \"\\\\0b\" BinChar-LEX\n    Character-CF.Octal = \"\\\\0\" OctChar-LEX\n    Character-CF.Decimal = \"\\\\\" NumChar-LEX\n    Character-CF.Hexadecimal = \"\\\\0x\" HexChar-LEX\n\ncontext-free syntax\n    Character.Bot = \"\\\\BOT\"\n    Character.Top = \"\\\\TOP\"\n    Character.LabelStart = \"\\\\LABEL_START\"\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/syntax/characterclass/Character.sdf3/#modal-h2","title":"Character.sdf3","text":""},{"location":"org.metaborg.meta.lang.template/syntax/constants/IdentifierCon.sdf3/","title":"<code>IdentifierCon.sdf3</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/syntax/constants/IdentifierCon.sdf3</p> <pre><code>module constants/IdentifierCon\n\nlexical syntax\n\n//head:[A-Za-z] tail:[A-Za-z\\_\\-0-9]* -&gt; IdCon {cons(\"default\")}\nIdCon.Default = [A-Za-z][A-Za-z\\_\\-0-9]*\n\nlexical restrictions\n\nIdCon -/- [A-Za-z\\_\\-0-9]\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/syntax/constants/IdentifierCon.sdf3/#modal-h2","title":"IdentifierCon.sdf3","text":""},{"location":"org.metaborg.meta.lang.template/syntax/constants/IntCon.sdf3/","title":"<code>IntCon.sdf3</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/syntax/constants/IntCon.sdf3</p> <pre><code>module constants/IntCon\n\nimports layout/Whitespace\n        constants/NatCon\n\ncontext-free syntax\n\n        IntCon.Natural = &lt;&lt;NatCon&gt;&gt;\n\n        //pos:\"+\" NatCon -&gt; IntCon {cons(\"positive\")}\n        IntCon.Positive = &lt;+&lt;NatCon&gt;&gt;\n        //neg:\"-\" NatCon -&gt; IntCon {cons(\"negative\")}\n        IntCon.Negative = &lt;-&lt;NatCon&gt;&gt;\n\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/syntax/constants/IntCon.sdf3/#modal-h2","title":"IntCon.sdf3","text":""},{"location":"org.metaborg.meta.lang.template/syntax/constants/NatCon.sdf3/","title":"<code>NatCon.sdf3</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/syntax/constants/NatCon.sdf3</p> <pre><code>module constants/NatCon\n\nlexical syntax\n\n NatCon.Digits = [0-9]+\n\nlexical restrictions\n\n NatCon -/- [0-9]\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/syntax/constants/NatCon.sdf3/#modal-h2","title":"NatCon.sdf3","text":""},{"location":"org.metaborg.meta.lang.template/syntax/constants/RealCon.sdf3/","title":"<code>RealCon.sdf3</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/syntax/constants/RealCon.sdf3</p> <pre><code>module constants/RealCon\n\nimports constants/IntCon\n                constants/NatCon\n\ncontext-free syntax\n        OptExp.Present = &lt;e&lt;IntCon&gt;&gt; //Change constructor name?\n        OptExp.Absent = &lt;&gt;\n        //base:IntCon \".\" decimal:NatCon exp:OptExp  -&gt; RealCon {cons(\"real-con\")}\n        RealCon.RealCon = &lt;&lt;base:IntCon&gt;.&lt;decimal:NatCon&gt;&lt;exp:OptExp&gt;&gt;   \n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/syntax/constants/RealCon.sdf3/#modal-h2","title":"RealCon.sdf3","text":""},{"location":"org.metaborg.meta.lang.template/syntax/constants/StrCon.sdf3/","title":"<code>StrCon.sdf3</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/syntax/constants/StrCon.sdf3</p> <pre><code>module constants/StrCon\n\nlexical syntax\n\n    StrChar.Newline = \"\\\\n\"       \n    StrChar.Tab = \"\\\\t\"                \n    StrChar.Quote = \"\\\\\\\"\"                     \n    StrChar.Backslash = \"\\\\\\\\\"                    \n    StrChar.Decimal = \"\\\\\" a:[0-9]b:[0-9]c:[0-9] \n    StrChar.Normal = ~[\\0-\\31\\n\\t\\\"\\\\]          \n\n    StrCon.Default = [\\\"] chars:StrChar* [\\\"]   \n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/syntax/constants/StrCon.sdf3/#modal-h2","title":"StrCon.sdf3","text":""},{"location":"org.metaborg.meta.lang.template/syntax/grammar/Grammars.sdf3/","title":"<code>Grammars.sdf3</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/syntax/grammar/Grammars.sdf3</p> <pre><code>module grammar/Grammars\n\nimports layout/Comments\n\ncontext-free syntax\n\n//Grammar.Empty = &lt;(/)&gt;\n//\"left\":Grammar \"right\":Grammar -&gt; Grammar  {assoc,cons(\"conc-grammars\")}\n//Grammar.ConcGrammars = &lt;&lt;Grammar&gt; &lt;Grammar&gt;&gt; {assoc} IGNORED RULE\n//Grammar = &lt;(&lt;Grammar&gt;)&gt; {bracket}\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/syntax/grammar/Grammars.sdf3/#modal-h2","title":"Grammars.sdf3","text":""},{"location":"org.metaborg.meta.lang.template/syntax/kernel/Kernel.sdf3/","title":"<code>Kernel.sdf3</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/syntax/kernel/Kernel.sdf3</p> <pre><code>module kernel/Kernel\n\nimports aterms/Aterms \n        symbols/Symbols \n        grammar/Grammars\n        constants/StrCon\n        priority/Priority\n        layout-constraints/Layout-Constraints\n\ncontext-free syntax\n\nATermAttribute.Default = &lt;&lt;aterm:ATerm&gt;&gt;\nAttribute.Term = &lt;&lt;ATermAttribute&gt;&gt;\n\nAttributes.Attrs = &lt;{&lt;list:{Attribute \", \"}*&gt;}&gt;\nAttributes.NoAttrs = &lt;&gt;\n\n\n\n//special attributes that should show up in the parse table as attr\n\nAttribute.Deprecated = &lt;deprecated(&lt;StrCon&gt;)&gt; \nAttribute.Constructor = &lt;cons(&lt;StrCon&gt;)&gt; {deprecated(\"Use 'Sort.Cons' notation instead\")}\nAttribute = &lt;&lt;QuotedConstructor&gt;&gt; {prefer, deprecated(\"Use 'Sort.Cons' notation instead\") }\nQuotedConstructor.Constructor = &lt;&lt;StrCon&gt;&gt;\n\nAttribute.Reject = &lt;reject&gt;\nAttribute.Prefer = &lt;prefer&gt; {deprecated(\"Prefer and avoid are deprecated and will be removed in a future version of SDF3\")}\nAttribute.Avoid = &lt;avoid&gt; {deprecated(\"Prefer and avoid are deprecated and will be removed in a future version of SDF3\")}\n\nAttribute.Bracket = &lt;bracket&gt;\nAttribute.Assoc = &lt;&lt;Associativity&gt;&gt;\n\nAttribute.LayoutConstraint = &lt;layout(&lt;Constraint&gt;)&gt;\n\nAttribute.IgnoreLayout = &lt;ignore-layout&gt;\nAttribute.EnforceNewLine = &lt;enforce-newline&gt;\nAttribute.LongestMatch = &lt;longest-match&gt;\nAttribute.Recover      = &lt;recover&gt;\n\nAttribute.CaseInsensitive = &lt;case-insensitive&gt;\nAttribute.Deprecated = &lt;deprecated&gt;  \n\n//new completion attributes\nAttribute.Placeholder = &lt;placeholder&gt; \nAttribute.PlaceholderInsertion = &lt;placeholder-insertion&gt; \nAttribute.LiteralCompletion = &lt;literal-completion&gt; \n\n\nProduction.Prod = &lt;&lt;Symbols&gt; -\\&gt; &lt;result:Symbol&gt; &lt;Attributes&gt;&gt; {deprecated(\"Use productive form instead\")}\n\nProductions = &lt;&lt;list:{Production \"\\n\"}*&gt;&gt;\n\nGrammar.Syntax = &lt;\n        syntax \n\n                &lt;Productions&gt;\n\n                &gt;\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/syntax/kernel/Kernel.sdf3/#modal-h2","title":"Kernel.sdf3","text":""},{"location":"org.metaborg.meta.lang.template/syntax/labels/Labels.sdf3/","title":"<code>Labels.sdf3</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/syntax/labels/Labels.sdf3</p> <pre><code>module labels/Labels\n\nimports kernel/Kernel \n        constants/StrCon\n        constants/IdentifierCon\n\ncontext-free syntax\n\nLabel.Quoted = &lt;&lt;StrCon&gt;&gt;\nLabel.Unquoted = &lt;&lt;IdCon&gt;&gt;\nSymbol.Label = &lt;&lt;Label&gt;:&lt;Symbol&gt;&gt;\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/syntax/labels/Labels.sdf3/#modal-h2","title":"Labels.sdf3","text":""},{"location":"org.metaborg.meta.lang.template/syntax/layout/Comments.sdf3/","title":"<code>Comments.sdf3</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/syntax/layout/Comments.sdf3</p> <pre><code>module layout/Comments\n\nimports\n  layout/Whitespace\n\nlexical syntax\n        LAYOUT = \"%%\" line:~[\\n\\r]* LayoutNewlineAlt        {category(\"Comment\")}\n        LayoutNewlineAlt = [\\n\\r]\n        LayoutNewlineAlt = EOF\n    LAYOUT = \"%\" content:~[\\%\\n\\r]+ \"%\"        {category(\"Comment\")}\n    LAYOUT = \"/*\" LayoutCommentAlt* \"*/\" \n    LayoutCommentAlt = ~[\\*]\n    LayoutCommentAlt = CommentChar\n    CommentChar = [\\*]\n    LAYOUT = \"//\" ~[\\n\\r]* LayoutNewlineAlt\n    EOF = \n\nlexical restrictions\n\n    CommentChar   -/- [\\/]\n\n    %% EOF may not be followed by any char\n\n    EOF           -/- ~[]          \n\n\ncontext-free restrictions \n    LAYOUT? -/- [\\%]\n    LAYOUT? -/- [\\ \\t\\n\\r]\n    LAYOUT? -/- [\\/].[\\/]\n    LAYOUT? -/- [\\/].[\\*]\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/syntax/layout/Comments.sdf3/#modal-h2","title":"Comments.sdf3","text":""},{"location":"org.metaborg.meta.lang.template/syntax/layout/Whitespace.sdf3/","title":"<code>Whitespace.sdf3</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/syntax/layout/Whitespace.sdf3</p> <pre><code>module layout/Whitespace \n\nlexical syntax    \n    LAYOUT = [\\ \\t\\n\\r]\n\ncontext-free restrictions\n    LAYOUT? -/- [\\ \\t\\n\\r] \n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/syntax/layout/Whitespace.sdf3/#modal-h2","title":"Whitespace.sdf3","text":""},{"location":"org.metaborg.meta.lang.template/syntax/layout-constraints/Layout-Constraints.sdf3/","title":"<code>Layout-Constraints.sdf3</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/syntax/layout-constraints/Layout-Constraints.sdf3</p> <pre><code>module layout-constraints/Layout-Constraints\n\nimports\n\n  constants/NatCon\n  constants/StrCon\n  constants/IdentifierCon\n\ntemplate options\n\n  keyword -/- [a-zA-Z0-9]\n\ncontext-free sorts\n\n  Constraint\n  ConstraintExp\n  ConstraintToken\n  ConstraintTreeRef\n\ncontext-free syntax\n\n  ConstraintTreeRef.PosRef = NatCon\n  ConstraintTreeRef.LiteralRef = StrCon\n  ConstraintTreeRef.LabelRef = IdCon\n\n  ConstraintToken.First = &lt;&lt;ConstraintTreeRef&gt;.first&gt;\n  ConstraintToken.Left = &lt;&lt;ConstraintTreeRef&gt;.left&gt;\n  ConstraintToken.Right = &lt;&lt;ConstraintTreeRef&gt;.right&gt;\n  ConstraintToken.Last = &lt;&lt;ConstraintTreeRef&gt;.last&gt;\n\n  ConstraintExp = &lt;(&lt;ConstraintExp&gt;)&gt; {bracket}\n  ConstraintExp.Mul = &lt;&lt;ConstraintExp&gt; * &lt;ConstraintExp&gt;&gt; {left}\n  ConstraintExp.Div = &lt;&lt;ConstraintExp&gt; / &lt;ConstraintExp&gt;&gt; {left}\n  ConstraintExp.Add = &lt;&lt;ConstraintExp&gt; + &lt;ConstraintExp&gt;&gt; {left}\n  ConstraintExp.Sub = &lt;&lt;ConstraintExp&gt; - &lt;ConstraintExp&gt;&gt; {left}\n  ConstraintExp.Line = &lt;&lt;ConstraintToken&gt;.line&gt;\n  ConstraintExp.Col = &lt;&lt;ConstraintToken&gt;.col&gt;\n  ConstraintExp.Num = NatCon\n\n  Constraint = &lt;(&lt;Constraint&gt;)&gt; {bracket}\n  Constraint.Eq = &lt;&lt;ConstraintExp&gt; == &lt;ConstraintExp&gt;&gt; {non-assoc}\n  Constraint.Lt = &lt;&lt;ConstraintExp&gt; \\&lt; &lt;ConstraintExp&gt;&gt; {non-assoc}\n  Constraint.Le = &lt;&lt;ConstraintExp&gt; \\&lt;= &lt;ConstraintExp&gt;&gt; {non-assoc}\n  Constraint.Gt = &lt;&lt;ConstraintExp&gt; \\&gt; &lt;ConstraintExp&gt;&gt; {non-assoc}\n  Constraint.Ge = &lt;&lt;ConstraintExp&gt; \\&gt;= &lt;ConstraintExp&gt;&gt; {non-assoc}\n  Constraint.Not = &lt;!&lt;Constraint&gt;&gt;\n  Constraint.And = &lt;&lt;Constraint&gt; &amp;&amp; &lt;Constraint&gt;&gt; {left}\n  Constraint.Or = &lt;&lt;Constraint&gt; || &lt;Constraint&gt;&gt; {left}\n\n  Constraint.Offside = &lt;offside &lt;ConstraintTreeRef&gt; &lt;{ConstraintTreeRef \", \"}*&gt;&gt;\n  Constraint.Indent = &lt;indent &lt;ConstraintTreeRef&gt; &lt;{ConstraintTreeRef \", \"}+&gt;&gt;\n  Constraint.Align = &lt;align &lt;ConstraintTreeRef&gt; &lt;{ConstraintTreeRef \", \"}+&gt;&gt;\n  Constraint.AlignList = &lt;align-list &lt;ConstraintTreeRef&gt;&gt;\n  Constraint.NewLineIndent = &lt;newline-indent &lt;ConstraintTreeRef&gt; &lt;{ConstraintTreeRef \", \"}+&gt;&gt;\n  Constraint.SingleLine = &lt;single-line &lt;ConstraintTreeRef*&gt;&gt;\n\n  Constraint.PPOffside = &lt;pp-offside &lt;ConstraintTreeRef&gt; &lt;{ConstraintTreeRef \", \"}*&gt;&gt;\n  Constraint.PPIndent = &lt;pp-indent &lt;ConstraintTreeRef&gt; &lt;{ConstraintTreeRef \", \"}+&gt;&gt;\n  Constraint.PPAlign = &lt;pp-align &lt;ConstraintTreeRef&gt; &lt;{ConstraintTreeRef \", \"}+&gt;&gt;\n  Constraint.PPAlignList = &lt;pp-align-list &lt;ConstraintTreeRef&gt;&gt;\n  Constraint.PPNewLineIndent = &lt;pp-newline-indent &lt;ConstraintTreeRef&gt; &lt;{ConstraintTreeRef \", \"}+&gt;&gt;\n  Constraint.PPNewLineIndentBy = &lt;pp-newline-indent-by(&lt;NatCon&gt;) &lt;ConstraintTreeRef&gt; &lt;{ConstraintTreeRef \", \"}+&gt;&gt;\n  Constraint.PPNewLine = &lt;pp-newline &lt;ConstraintTreeRef&gt;&gt;\n  Constraint.PPNewLineBy = &lt;pp-newline(&lt;NatCon&gt;) &lt;ConstraintTreeRef&gt;&gt;\n\ncontext-free priorities\n\n    Constraint.Not &gt;\n    {non-assoc:\n      Constraint.Eq\n      Constraint.Lt\n      Constraint.Le\n      Constraint.Gt\n      Constraint.Ge\n    } &gt;\n    Constraint.And &gt;\n    Constraint.Or,\n\n    {left: ConstraintExp.Mul ConstraintExp.Div} &gt; {left: ConstraintExp.Add ConstraintExp.Sub}\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/syntax/layout-constraints/Layout-Constraints.sdf3/#modal-h2","title":"Layout-Constraints.sdf3","text":""},{"location":"org.metaborg.meta.lang.template/syntax/lifting/Lifting.sdf3/","title":"<code>Lifting.sdf3</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/syntax/lifting/Lifting.sdf3</p> <pre><code>module lifting/Lifting\n\nimports kernel/Kernel\n\n\ncontext-free syntax\n\n//left-quote:\"`\" Symbol right-quote:\"`\" -&gt; Symbol  {cons(\"lifting\")}\n//Symbol.Lifting = &lt;`&lt;Symbol&gt;`&gt;\n\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/syntax/lifting/Lifting.sdf3/#modal-h2","title":"Lifting.sdf3","text":""},{"location":"org.metaborg.meta.lang.template/syntax/literals/Literals.sdf3/","title":"<code>Literals.sdf3</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/syntax/literals/Literals.sdf3</p> <pre><code>module literals/Literals\n\nimports kernel/Kernel \n constants/StrCon\n constants/IdentifierCon\n\nlexical syntax\n\n    SingleQuotedStrChar.Newline = \"\\\\n\"                    \n    SingleQuotedStrChar.Tab = \"\\\\t\"                   \n    SingleQuotedStrChar.Quote = \"\\\\'\"           \n    SingleQuotedStrChar.Backslash = \"\\\\\\\\\"                    \n    SingleQuotedStrChar.Decimal = \"\\\\\" a:[0-9]b:[0-9]c:[0-9] \n    SingleQuotedStrChar.Normal = ~[\\0-\\31\\n\\t\\'\\\\] \n\n    SingleQuotedStrCon.Default =  [\\'] chars:SingleQuotedStrChar* [\\'] \n\ncontext-free syntax\n        FunctionName.UnquotedFun = &lt;&lt;IdCon&gt;&gt;\n        FunctionName.QuotedFun = &lt;&lt;StrCon&gt;&gt;\n\ncontext-free syntax\n        Symbol.Lit = &lt;&lt;string:StrCon&gt;&gt;\n        Symbol.CiLit = &lt;&lt;ci-string:SingleQuotedStrCon&gt;&gt;\n        //Production.PrefixFun = &lt;&lt;fun:FunctionName&gt;(&lt;arguments:{Symbol \", \"}*&gt;) -\\&gt; &lt;result:Symbol&gt; &lt;Attributes&gt;&gt;\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/syntax/literals/Literals.sdf3/#modal-h2","title":"Literals.sdf3","text":""},{"location":"org.metaborg.meta.lang.template/syntax/modules/Modules.sdf3/","title":"<code>Modules.sdf3</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/syntax/modules/Modules.sdf3</p> <pre><code>module modules/Modules\n\nimports kernel/Kernel \n        renaming/Renaming\n        symbols/Symbols\n\nlexical syntax\n    //letters:[A-Za-z0-9\\_\\-]+ -&gt; ModuleWord  {cons(\"word\")}\n        ModuleWord.Word = [A-Za-z0-9\\_\\-]+\n\n    ModuleId.Leaf =  ModuleWord\n    //sep:\"/\" basename:ModuleId            -&gt; ModuleId  {cons(\"root\")}\n    ModuleId.Root = \"/\" ModuleId\n    //dirname:ModuleWord sep:\"/\" basename:ModuleId -&gt; ModuleId  {cons(\"path\")}\n    ModuleId.Path = ModuleWord \"/\" ModuleId\n\n\ncontext-free syntax\n        //Definition = &lt;&lt;list:Module*&gt;&gt;\n\n        Module.Module = &lt;\n        module &lt;ModuleName&gt;\n\n        &lt;list:ImpSection*&gt;\n\n        &lt;Sections&gt;&gt;\n\n        //Section.Exports = &lt;exports &lt;Grammar&gt;&gt;\n        //Section.Hiddens = &lt;hiddens &lt;Grammar&gt;&gt;\n\n    Sections = &lt;&lt;{Section \"\\n\"}*&gt;&gt;\n\n    Section.SDFSection = &lt;&lt;Grammar&gt;&gt;\n\n        ModuleName.Unparameterized = &lt;&lt;ModuleId&gt;&gt;\n        ModuleName.Parameterized = &lt;&lt;ModuleId&gt; [&lt;params:Symbols&gt;]&gt;\n\n//        Attribute.Id = &lt;id (&lt;ModuleName&gt;) &gt; \n\n        ImpSection.Imports = &lt;\n        imports \n                &lt;list:Imports&gt;&gt;\n\n        //Grammar.ImpSection = &lt;&lt;ImpSection&gt;&gt; IGNORED PRODUCTION\n\n        Imports = &lt;&lt;list:{Import \"\\n\\t\"}*&gt;&gt;\n\n        Import.Module = &lt;&lt;ModuleName&gt;&gt;\n        //Import.RenamedModule = &lt;&lt;ModuleName&gt; &lt;Renamings&gt;&gt; IGNORED PRODUCTION\n        //Import = &lt;(&lt;Import&gt;)&gt; {bracket}\n\n  lexical restrictions\n    ModuleWord -/- [A-Za-z0-9\\_\\-]\n    ModuleId -/- [\\/]\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/syntax/modules/Modules.sdf3/#modal-h2","title":"Modules.sdf3","text":""},{"location":"org.metaborg.meta.lang.template/syntax/priority/Priority.sdf3/","title":"<code>Priority.sdf3</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/syntax/priority/Priority.sdf3</p> <pre><code>module priority/Priority\n\nimports kernel/Kernel constants/NatCon TemplateLang\n\ncontext-free syntax\n\nAssociativity.Left = &lt;left&gt;\nAssociativity.Right = &lt;right&gt;\nAssociativity.NonAssoc = &lt;non-assoc&gt;\nAssociativity.Assoc = &lt;assoc&gt;\nAssociativity.NonNested = &lt;non-nested&gt;\n\n\n\nArgumentIndicator.Default = &lt;\\&lt;&lt;arguments:{NatCon \",\"}+&gt;\\&gt;&gt;\nGroup.WithArguments = &lt;&lt;Group&gt; &lt;ArgumentIndicator&gt;&gt; {non-assoc}\nGroup.NonTransitive = &lt;&lt;Group&gt;.&gt; {non-assoc}\n\nGroup.SimpleGroup = &lt;&lt;PriorityProduction&gt;&gt;\nGroup.ProdsGroup = &lt;{&lt;PriorityProductions&gt;}&gt;\nGroup.AssocGroup = &lt;\n        {&lt;Associativity&gt;: \n                &lt;PriorityProductions&gt;}&gt; \n\n\nPriorityProduction = &lt;&lt;SdfProduction&gt;&gt;\nPriorityProduction = &lt;&lt;Production&gt;&gt;\nPriorityProductions = &lt;&lt;list:{PriorityProduction \"\\n\"}*&gt;&gt;\n\n\nPriority.Chain = &lt;&lt;list:{Group \" &gt; \"}+&gt;&gt;\n//\"left\":Group Associativity \"right\":Group             -&gt; Priority  {cons(\"assoc\")}\nPriority.Assoc = &lt;&lt;Group&gt; &lt;Associativity&gt; &lt;Group&gt;&gt;\n\nPriorities = &lt;&lt;list:{Priority \",\\n\"}*&gt;&gt;\nGrammar.Priorities = &lt;\n        priorities \n\n                &lt;Priorities&gt;\n\n                &gt;\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/syntax/priority/Priority.sdf3/#modal-h2","title":"Priority.sdf3","text":""},{"location":"org.metaborg.meta.lang.template/syntax/regular/Regular.sdf3/","title":"<code>Regular.sdf3</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/syntax/regular/Regular.sdf3</p> <pre><code>module regular/Regular\n\nimports kernel/Kernel constants/IntCon symbols/Symbols constants/StrCon labels/Labels sorts/Sorts\n\ncontext-free syntax \n\n// Symbol.Empty = &lt;()&gt;\nSymbol.Sequence = &lt;(&lt;head:Symbol&gt; &lt;tail:Symbol+&gt;)&gt;\n// Symbol.Tuple = &lt;\\&lt;&lt;head:Symbol&gt; , &lt;rest:Symbol+; separator=\",\"&gt;\\&gt;&gt;\n\n\nSymbol.Opt = &lt;&lt;Symbol&gt;?&gt;\nSymbol.Iter = &lt;&lt;Symbol&gt;+&gt;\nSymbol.IterStar = &lt;&lt;Symbol&gt;*&gt;\nSymbol.IterSep = &lt;{&lt;Symbol&gt; &lt;sep:Separator&gt;}+&gt;\nSymbol.IterStarSep = &lt;{&lt;Symbol&gt; &lt;sep:Separator&gt;}*&gt;\n\n\n\nSortSymbol.Opt = &lt;&lt;Sort&gt;?&gt;\nSortSymbol.Iter = &lt;&lt;Sort&gt;+&gt;\nSortSymbol.IterStar = &lt;&lt;Sort&gt;*&gt;\nSortSymbol.IterSep = &lt;{&lt;Sort&gt; &lt;sep:Separator&gt;}+&gt;\nSortSymbol.IterStarSep = &lt;{&lt;Sort&gt; &lt;sep:Separator&gt;}*&gt;\nSeparator.Lit = &lt;&lt;StrCon&gt;&gt;\n\n\nSymbol = &lt;&lt;SortSymbol&gt;?&gt; {reject}\nSymbol = &lt;&lt;SortSymbol&gt;+&gt; {reject}\nSymbol = &lt;&lt;SortSymbol&gt;*&gt; {reject}\nSymbol = &lt;{&lt;SortSymbol&gt; &lt;sep:Separator&gt;}+&gt; {reject}\nSymbol = &lt;{&lt;SortSymbol&gt; &lt;sep:Separator&gt;}*&gt; {reject}\n\n\n\n//Symbol.Func = &lt;(&lt;arguments:Symbols&gt; =\\&gt; &lt;results:Symbol&gt;)&gt;\n//\"left\":Symbol \"|\" \"right\":Symbol              - &gt; Symbol {right,cons(\"alt\")}\nSymbol.Alt = &lt;&lt;Symbol&gt; | &lt;Symbol&gt;&gt; {right}\n// \"(\" \"left\":Symbol \"-&gt;\" \"right\":Symbol \")\"     -&gt; Symbol {cons(\"strategy\")}\n//Symbol.Strategy = &lt;(&lt;Symbol&gt; -\\&gt; &lt;Symbol&gt; )&gt;\n\ncontext-free priorities \n{Symbol.Opt\n Symbol.IterStar\n Symbol.Iter} &gt;\n Symbol.Alt &gt;\n Symbol.Label\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/syntax/regular/Regular.sdf3/#modal-h2","title":"Regular.sdf3","text":""},{"location":"org.metaborg.meta.lang.template/syntax/renaming/Renaming.sdf3/","title":"<code>Renaming.sdf3</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/syntax/renaming/Renaming.sdf3</p> <pre><code>module renaming/Renaming\n\nimports kernel/Kernel symbols/Symbols\n\ncontext-free syntax\n\nRenamings.Renamings = &lt;[&lt;list:Renaming*&gt;]&gt;\nRenaming.Symbol = &lt;&lt;from:Symbol&gt; =\\&gt; &lt;to:Symbol&gt;&gt;\nRenaming.Production = &lt;&lt;from-prod:Production&gt; =\\&gt; &lt;to-prod:Production&gt;&gt;\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/syntax/renaming/Renaming.sdf3/#modal-h2","title":"Renaming.sdf3","text":""},{"location":"org.metaborg.meta.lang.template/syntax/restrictions/Restrictions.sdf3/","title":"<code>Restrictions.sdf3</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/syntax/restrictions/Restrictions.sdf3</p> <pre><code>module restrictions/Restrictions\n\nimports characterclass/CC \n                characterclass/Character-Class\n                symbols/Symbols \n                constants/StrCon\n\ncontext-free syntax\n\nLookahead.CharClass = &lt;&lt;CharClass&gt;&gt;\nLookahead.Seq = &lt;&lt;CharClass&gt;.&lt;Lookaheads&gt;&gt;  \n\nLookaheads.Single = &lt;&lt;Lookahead&gt;&gt;\n//\"left\":Lookaheads \"|\" \"right\":Lookaheads -&gt; Lookaheads  {cons(\"alt\"),right}\nLookaheads.Alt = &lt;&lt;Lookaheads&gt; | &lt;Lookaheads&gt;&gt; {right}\nLookaheads = &lt;(&lt;Lookaheads&gt;)&gt; {bracket}\nLookaheads.List = &lt;[[&lt;list:{Lookahead \", \"}*&gt;]]&gt;\n\nRestriction.Follow = &lt;&lt;RestrictionSymbols&gt; -/- &lt;Lookaheads&gt;&gt;\nRestrictionSymbols = &lt;&lt;list:{Symbol \"\\n\"}*&gt;&gt;\n\nRestrictions = &lt;&lt;list:{Restriction \"\\n\"}*&gt;&gt;\n\nGrammar.Restrictions = &lt;\n        restrictions\n\n                &lt;Restrictions&gt;\n\n        &gt;\n\n\ncontext-free priorities    \n    Lookahead.Seq &gt; \n    Lookaheads.Alt\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/syntax/restrictions/Restrictions.sdf3/#modal-h2","title":"Restrictions.sdf3","text":""},{"location":"org.metaborg.meta.lang.template/syntax/sdf2-core/SDF.sdf3/","title":"<code>SDF.sdf3</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/syntax/sdf2-core/SDF.sdf3</p> <pre><code>module sdf2-core/SDF\nimports sdf2-core/Sdf2 modules/Modules\n\ncontext-free syntax\nGroup.NonTransitive = &lt;&lt;Group&gt;.&gt; {non-assoc}\n\n%% HACK\n//  context-free syntax\n//  Group \".\" -&gt; Group {non-assoc,cons(\"non-transitive\")}\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/syntax/sdf2-core/SDF.sdf3/#modal-h2","title":"SDF.sdf3","text":""},{"location":"org.metaborg.meta.lang.template/syntax/sdf2-core/Sdf2-Syntax.sdf3/","title":"<code>Sdf2-Syntax.sdf3</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/syntax/sdf2-core/Sdf2-Syntax.sdf3</p> <pre><code>module sdf2-core/Sdf2-Syntax\n\nimports kernel/Kernel\n        basic/Basic\n        modules/Modules\n        regular/Regular\n        lifting/Lifting\n        priority/Priority\n        characterclass/CC\n        sorts/Sorts\n        symbols/Start-Symbols\n        literals/Literals\n        labels/Labels\n        restrictions/Restrictions\n        aliases/Aliases\n\ncontext-free syntax\n\nSymbol.Start = &lt;\\&lt;START\\&gt;&gt;\nSymbol.FileStart = &lt;\\&lt;Start\\&gt;&gt;\nSymbol.EOF = &lt;\\&lt;EOF\\&gt;&gt;\n\nGrammar.LexicalPriorities = &lt;\n        lexical priorities \n\n                &lt;Priorities&gt;\n\n        &gt;\n\nGrammar.ContextFreePriorities = &lt;\n        context-free priorities\n\n                &lt;Priorities&gt;\n\n        &gt;\n\nGrammar.LexicalRestrictions = &lt;\n        lexical restrictions\n\n                &lt;Restrictions&gt;\n\n        &gt;\n\nGrammar.ContextFreeRestrictions = &lt;\n        context-free restrictions\n\n                &lt;Restrictions&gt;\n\n        &gt;\n\n//SDF.Definition = &lt;definition &lt;Definition&gt;&gt; IGNORED PRODUCTION\n\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/syntax/sdf2-core/Sdf2-Syntax.sdf3/#modal-h2","title":"Sdf2-Syntax.sdf3","text":""},{"location":"org.metaborg.meta.lang.template/syntax/sdf2-core/Sdf2.sdf3/","title":"<code>Sdf2.sdf3</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/syntax/sdf2-core/Sdf2.sdf3</p> <pre><code>module sdf2-core/Sdf2\n\nimports \n  aterms/Aterms\n  sdf2-core/Sdf2-Syntax \n  constants/StrCon \n  constants/NatCon \n  priority/Priority \n  characterclass/Character \n  modules/Modules\n  layout-constraints/Layout-Constraints\n\ncontext-free start-symbols\n    Module\n\nlexical syntax\n          Sort = \"LAYOUT\" {reject}\n\ncontext-free syntax\n\n    ModuleName = &lt;aliases&gt; {reject}\n    ModuleName = &lt;lexical&gt; {reject}\n    ModuleName = &lt;priorities&gt; {reject}\n    ModuleName = &lt;context-free&gt; {reject}\n    ModuleName = &lt;definition&gt; {reject}\n    ModuleName = &lt;syntax&gt; {reject}\n    ModuleName = &lt;variables&gt; {reject}\n    ModuleName = &lt;module&gt; {reject}\n    ModuleName = &lt;imports&gt; {reject}\n    ModuleName = &lt;exports&gt; {reject}\n    ModuleName = &lt;hiddens&gt; {reject}\n    ModuleName = &lt;left&gt; {reject}\n    ModuleName = &lt;right&gt; {reject}\n    ModuleName = &lt;assoc&gt; {reject}\n    ModuleName = &lt;non-assoc&gt; {reject}\n    ModuleName = &lt;non-nested&gt; {reject}\n    ModuleName = &lt;bracket&gt; {reject}\n    ModuleName = &lt;sorts&gt; {reject}\n    ModuleName = &lt;restrictions&gt; {reject}\n\n    //restrictions from SDF3\n    ModuleName = &lt;language&gt; {reject}\n    ModuleName = &lt;project&gt; {reject}\n    ModuleName = &lt;retain&gt; {reject}\n    ModuleName = &lt;with&gt;  {reject}\n    ModuleName = &lt;unimports&gt; {reject}\n    ModuleName = &lt;overlays&gt; {reject}\n    ModuleName = &lt;rules&gt; {reject}\n    ModuleName = &lt;signature&gt; {reject}\n    ModuleName = &lt;strategies&gt; {reject}\n    ModuleName = &lt;attributes&gt; {reject}\n    ModuleName = &lt;template&gt; {reject}\n    ModuleName = &lt;templates&gt; {reject}\n    ModuleName = &lt;as&gt; {reject}\n    ModuleName = &lt;main&gt; {reject}\n    ModuleName = &lt;__default&gt; {reject}\n    ModuleName = &lt;__internal&gt; {reject}\n\n    Symbols = &lt;&lt;StrCon&gt;(&lt;arguments:{Symbol \",\"}*&gt;)&gt; {reject}\n\n    Label = &lt;&lt;Associativity&gt;&gt; {reject}\n    ATermAttribute = &lt;&lt;Associativity&gt;&gt; {reject}\n    ATermAttribute = &lt;reject&gt; {reject}\n    ATermAttribute = &lt;prefer&gt; {reject}\n    ATermAttribute = &lt;avoid&gt; {reject}\n    ATermAttribute = &lt;bracket&gt; {reject}\n    ATermAttribute = &lt;ignore-layout&gt; {reject}\n    ATermAttribute = &lt;deprecated&gt; {reject}\n    ATermAttribute = &lt;enforce-newline&gt; {reject}\n    ATermAttribute = &lt;longest-match&gt; {reject}\n    ATermAttribute = &lt;case-insensitive&gt; {reject}\n    ATermAttribute = &lt;placeholder&gt; {reject}\n    ATermAttribute = &lt;placeholder-insertion&gt; {reject}\n    ATermAttribute = &lt;literal-completion&gt; {reject}\n    ATermAttribute = &lt;layout(&lt;Constraint&gt;)&gt; {reject}\n    ATermAttribute = &lt;layout(&lt;ATerm&gt;)&gt; {reject}\n    ATermAttribute = &lt;deprecated(&lt;StrCon&gt;)&gt; {reject}\n    ATermAttribute.Constructor = &lt;cons(&lt;StrCon&gt;)&gt;{reject}\n    ATermAttribute = &lt;id(&lt;ModuleName&gt;)&gt; {reject}\n    ATermAttribute = &lt;recover&gt; {reject}\n\n  restrictions\n    Sort-CF\n    \"aliases\"\n    \"lexical\"\n    \"priorities\"\n    \"context-free\"\n    \"definition\"\n    \"syntax\"\n    \"variables\"\n    \"module\"\n    \"imports\"\n    \"exports\"\n    \"hiddens\"\n    \"left\"\n    \"right\"\n    \"assoc\"\n    \"non-assoc\"\n    \"non-nested\"\n    \"bracket\"\n    \"sorts\"             -/- [A-Za-z0-9\\_]\n    NatCon-CF        -/- [0-9]\n    LAYOUT?-CF        -/- [\\ \\t\\n\\%]\n    ModuleName-CF    -/- [A-Za-z0-9\\_\\-]\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/syntax/sdf2-core/Sdf2.sdf3/#modal-h2","title":"Sdf2.sdf3","text":""},{"location":"org.metaborg.meta.lang.template/syntax/sorts/Sorts.sdf3/","title":"<code>Sorts.sdf3</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/syntax/sorts/Sorts.sdf3</p> <pre><code>module sorts/Sorts\n\nimports kernel/Kernel\nsymbols/Symbols\nbasic/Basic\nregular/Regular\n\nlexical syntax\n  //head:[A-Z] -&gt; Sort {cons(\"one-char\")}\n  Sort.OneChar = [A-Z]\n  //head:[A-Z] middle:[A-Za-z0-9\\_\\-]* last:[A-Za-z0-9] -&gt; Sort {cons(\"more-chars\")}\n  Sort.MoreChars = [A-Z] [A-Za-z0-9\\_\\-]* [A-Za-z0-9]\n\ncontext-free syntax\nSymbol.Sort = &lt;&lt;Sort&gt;&gt;\nSymbol.ParameterizedSort = &lt;&lt;Sort&gt; [[&lt;parameters:{Symbol \", \"}+&gt;]]&gt;\nSymbolDef.SortDef = &lt;&lt;Sort&gt;&gt; {prefer}\nSymbolDef.Cf      = &lt;&lt;SymbolDef&gt;-CF&gt; {prefer}\nSymbolDef.Lex     = &lt;&lt;SymbolDef&gt;-LEX&gt; {prefer}\nSymbolDef.Var     = &lt;&lt;SymbolDef&gt;-VAR&gt; {prefer}\n\nDeclSort.DeclSort    = &lt;&lt;Sort&gt;&gt;     // context-free\nDeclSort.DeclSortCf  = &lt;&lt;Sort&gt;-CF&gt;  // desugared to DeclSort\nDeclSort.DeclSortLex = &lt;&lt;Sort&gt;-LEX&gt;\nDeclSort.DeclSortVar = &lt;&lt;Sort&gt;-VAR&gt;\n\n\nGrammar.Sorts = &lt;\n  sorts &lt;DeclSort*&gt;\n\n    &gt;\nGrammar.LexSorts = /* desugared */ &lt;\n  lexical sorts &lt;Sort*&gt;\n\n    &gt;\nGrammar.CfSorts = /* desugared */ &lt;\n  context-free sorts &lt;Sort*&gt;\n\n    &gt;\nGrammar.VarSorts = /* desugared */ &lt;\n  variable sorts &lt;Sort*&gt;\n\n    &gt;\n\nlexical restrictions\n    Sort -/- [A-Za-z0-9\\_]\n\ncontext-free priorities\n\n{ SymbolDef.Cf SymbolDef.Lex SymbolDef.Var Symbol.Cf Symbol.Lex Symbol.Varsym} &gt; Symbol.Alt\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/syntax/sorts/Sorts.sdf3/#modal-h2","title":"Sorts.sdf3","text":""},{"location":"org.metaborg.meta.lang.template/syntax/symbols/Start-Symbols.sdf3/","title":"<code>Start-Symbols.sdf3</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/syntax/symbols/Start-Symbols.sdf3</p> <pre><code>module symbols/Start-Symbols\n\nimports kernel/Kernel\nsymbols/Symbols\n\ncontext-free syntax\nGrammar.KernelStartSymbols = &lt;\n  start-symbols &lt;Symbols&gt;\n\n  &gt;\n\nGrammar.LexicalStartSymbols = &lt;\n  lexical start-symbols &lt;Symbols&gt;\n\n  &gt;\n\nGrammar.ContextFreeStartSymbols = &lt;\n  context-free start-symbols &lt;Symbols&gt;\n\n  &gt;\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/syntax/symbols/Start-Symbols.sdf3/#modal-h2","title":"Start-Symbols.sdf3","text":""},{"location":"org.metaborg.meta.lang.template/syntax/symbols/Symbols.sdf3/","title":"<code>Symbols.sdf3</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/syntax/symbols/Symbols.sdf3</p> <pre><code>module symbols/Symbols\n\nimports layout/Comments\n\ncontext-free syntax\n\nSymbol = &lt;(&lt;Symbol&gt;)&gt; {bracket}\nSymbols = &lt;&lt;list:Symbol*&gt;&gt;\nSymbolDef = &lt;&lt;Symbol&gt;&gt;\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/syntax/symbols/Symbols.sdf3/#modal-h2","title":"Symbols.sdf3","text":""},{"location":"org.metaborg.meta.lang.template/trans/analysis/names.nab/","title":"<code>names.nab</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/trans/analysis/names.nab</p> <pre><code>module analysis/names\n\nimports\n  signatures/TemplateLang-sig\n  analysis/types\n  libstrc\n\n\nnamespaces\n\n  Module Sort\n  Constructor Label\n  DeclSort\n\n\nproperties\n\n  def of Constructor       : SdfProduction\n  sort of Constructor      : Sort\n  ast of Module            : Module\n\n  constructorName of Sort           : Constructor\n\nbinding rules\n\n  mod@Module(Unparameterized(m), i*, s*):\n    defines Module m\n    scopes Sort, Constructor\n\n  Module(Unparameterized(m)):\n    imports Sort, Constructor from Module m\n\n  //Kernel Productions\n  p@SdfProductionWithCons(SortCons(Lex(SortDef(s)), Constructor(c)), rhs, attrs):\n    defines non-unique Sort s of type SortType(s) of constructorName c\n    defines unique Constructor c\n      of type FunType(ty*, SortType(s))\n      where rhs has type ty*\n    scopes Label\n\n\n  p@SdfProduction(Lex(SortDef(s)), rhs, attrs):\n    defines non-unique Sort s of type SortType(s)\n    scopes Label\n\n   p@SdfProductionWithCons(SortCons(Cf(SortDef(s)), Constructor(c)), rhs, attrs):\n    defines non-unique Sort s of type SortType(s)  of constructorName c\n    defines unique Constructor c\n      of type FunType(ty*, SortType(s))\n      where rhs has type ty*\n    scopes Label\n\n  p@SdfProduction(Cf(SortDef(s)), rhs, attrs):\n    defines non-unique Sort s of type SortType(s)\n    scopes Label\n\n  //Regular Productions\n  p@SdfProductionWithCons(SortCons(SortDef(s), Constructor(c)), rhs, attrs):\n    defines non-unique Sort s of type SortType(s) of constructorName c\n    defines unique Constructor c\n      of type FunType(ty*, SortType(s))\n      where rhs has type ty*\n    scopes Label\n\n  p@SdfProduction(SortDef(s), rhs, attrs):\n    defines non-unique Sort s of type SortType(s)\n    scopes Label\n\n  p@TemplateProductionWithCons(SortCons(SortDef(s), Constructor(c)), t, attrs):\n    defines non-unique Sort s of type SortType(s) of constructorName c\n    defines unique Constructor c\n      of type FunType(ty*, SortType(s))\n     where t has type ty*\n     scopes Label\n\n  p@TemplateProduction(SortDef(s), t, attrs):\n    defines non-unique Sort s of type SortType(s)\n    scopes Label\n\n DeclSort(s):     // context-free\n  defines non-unique Sort s of type SortType(s)\n//  defines DeclSort s\n DeclSortLex(s):\n  defines non-unique Sort s of type SortType(s)\n//  defines DeclSort s\n DeclSortVar(s):\n  defines non-unique Sort s of type SortType(s)\n//  defines DeclSort s\n\n SortConsRef(Sort(s), Constructor(c)):\n    refers to Sort s\n    refers to Constructor c of sort s\n\n  SortConsRef(Lex(Sort(s)), Constructor(c)):\n    refers to Sort s\n    refers to Constructor c of sort s\n\n   SortConsRef(Cf(Sort(s)), Constructor(c)):\n    refers to Sort s\n    refers to Constructor c of sort s\n\n Sort(s):\n   refers to Sort s\n\n Label(Unquoted(l), _):\n  defines unique Label l\n\n LabelRef(l):\n  refers to Label l\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/trans/analysis/names.nab/#modal-h2","title":"names.nab","text":""},{"location":"org.metaborg.meta.lang.template/trans/statix/attribute.stx/","title":"<code>attribute.stx</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/trans/statix/attribute.stx</p> <pre><code>module statix/attribute\n\nimports\n\n  statix/util\n\nsignature\n\n  sorts Attributes constructors\n    Attrs   : list(Attribute) -&gt; Attributes\n    NoAttrs :                    Attributes\n\n  sorts Attribute constructors\n    Reject  : Attribute\n    Bracket : Attribute\n\nrules\n\n  hasAttribute: Attribute * Attributes -&gt; BOOL\n  hasAttribute(attr, attrs) = hasAttributeInList(attr, attributes(attrs)).\n\n  attributes: Attributes -&gt; list(Attribute)\n  attributes(Attrs(attributes)) = attributes.\n  attributes(NoAttrs())         = [].\n\n  hasAttributeInList: Attribute * list(Attribute) -&gt; BOOL\n  hasAttributeInList(attr, [attr|_]) = TRUE().\n  hasAttributeInList(attr, [_   |s]) = hasAttributeInList(attr, s).\n  hasAttributeInList(attr, [      ]) = FALSE().\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/trans/statix/attribute.stx/#modal-h2","title":"attribute.stx","text":""},{"location":"org.metaborg.meta.lang.template/trans/statix/cons.stx/","title":"<code>cons.stx</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/trans/statix/cons.stx</p> <pre><code>module statix/cons\n\nimports\n\n  statix/name\n  statix/type\n  statix/util\n\nrules // Constructor reusable predicates\n\n  declareConstructor : scope * list(TYPE) * TYPE * string -&gt; TYPE\n  declareConstructor(s, Tsymbols, Tsort, name) = Tprod :- {results}\n    Tprod == PROD(Tsymbols, Tsort),\n    s -&gt; Constructor{name} with typeOfDecl Tprod,\n    typeOfDecl of Constructor{name} in s |-&gt; results,\n    onlyOneOf(Tprod, results) | error $[Duplicate definition of constructor [name]]@name,\n    @name.type := Tprod.\n\n  typeOfConstructor : scope * string -&gt; TYPE\n  typeOfConstructor(s, name) = Tprod :- {paths}\n    typeOfDecl of Constructor{name} in s |-&gt; paths,\n    resolveConstructors(name, paths, NON_EMPTY()) == Tprod,\n    @name.type := Tprod.\n\n  resolveConstructors : string * list((path * (occurrence * TYPE))) * EMPTINESS -&gt; TYPE\n  resolveConstructors(name, [(_, (Constructor{name'}, Tprod))|paths], _) = Tprod :-\n    @name.ref += name',\n    resolveConstructors(name, paths, MAYBE_EMPTY()) == Tprod.\n  resolveConstructors(name, [], NON_EMPTY())   = _ :- false | error $[Constructor [name] not defined]@name.\n  resolveConstructors(name, [], MAYBE_EMPTY()) = _.\n\n  typeOfConstructorInSort : scope * string * TYPE -&gt; TYPE\n  typeOfConstructorInSort(s, name, Tsort) = Tprod :- {paths}\n    typeOfDecl of Constructor{name} in s |-&gt; paths,\n    resolveConstructorsInSort(name, Tsort, paths, NON_EMPTY()) == Tprod,\n    @name.type := Tprod.\n\n  resolveConstructorsInSort : string * TYPE * list((path * (occurrence * TYPE))) * EMPTINESS -&gt; TYPE\n  resolveConstructorsInSort(name, Tsort, [(_, (Constructor{name'}, Tprod@PROD(_, Tsort)))|paths], _) = Tprod :-\n    @name.ref += name',\n    resolveConstructorsInSort(name, Tsort, paths, MAYBE_EMPTY()) == _.\n  resolveConstructorsInSort(name, Tsort, [(_, (Constructor{name'}, _))|paths], emptiness) = Tprod :-\n    resolveConstructorsInSort(name, Tsort, paths, emptiness) == Tprod.\n  resolveConstructorsInSort(name, Tsort, [], NON_EMPTY())   = _ :- false | error $[Constructor [name] not defined in [Tsort]]@name.\n  resolveConstructorsInSort(name, Tsort, [], MAYBE_EMPTY()) = _.\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/trans/statix/cons.stx/#modal-h2","title":"cons.stx","text":""},{"location":"org.metaborg.meta.lang.template/trans/statix/label.stx/","title":"<code>label.stx</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/trans/statix/label.stx</p> <pre><code>module statix/label\n\nimports\n\n  statix/name\n  statix/util\n\nsignature\n\n  sorts Label constructors\n    Quoted   : string -&gt; Label\n    Unquoted : string -&gt; Label\n\nrules\n\n  labelOK: scope * Label\n  labelOK(s, Quoted(name))   :- declareLabel(s, name).\n  labelOK(s, Unquoted(name)) :- declareLabel(s, name).\n\nrules // Label reusable predicates\n\n  declareLabel : scope * string\n  declareLabel(s, name) :-\n    s -&gt; Label{name},\n    Label{name} in s |-&gt; [(_, (_))] | error $[Duplicate definition of label [name]]@name.\n\n  resolveLabel : scope * string\n  resolveLabel(s, name)  :- {paths}\n    Label{name} in s |-&gt; paths,\n    resolveLabels(name, paths, NON_EMPTY()).\n\n  resolveLabels : string * list((path * occurrence)) * EMPTINESS\n  resolveLabels(name, [(_, (Label{name'}))|labels], _) :-\n    @name.ref += name',\n    resolveLabels(name, labels, MAYBE_EMPTY()).\n  resolveLabels(name, [], NON_EMPTY()) :- false | error $[Label [name] is not defined]@name.\n  resolveLabels(name, [], MAYBE_EMPTY()).\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/trans/statix/label.stx/#modal-h2","title":"label.stx","text":""},{"location":"org.metaborg.meta.lang.template/trans/statix/main.stx/","title":"<code>main.stx</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/trans/statix/main.stx</p> <pre><code>module statix/main\n\nimports\n\n  statix/name\n  statix/type\n  statix/module\n  statix/section/section\n  statix/section/grammar\n  statix/section/template\n  statix/section/syntax\n  statix/section/start_symbol\n  statix/section/sort\n  statix/section/priority\n  statix/section/restriction\n  statix/production\n  statix/sort_cons\n  statix/symbol\n  statix/attribute\n  statix/label\n  statix/util\n\nrules\n\n  projectOK : scope\n  projectOK(s).\n\n  fileOK: scope * Module\n  fileOK(s, m) :- moduleOK(s, m).\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/trans/statix/main.stx/#modal-h2","title":"main.stx","text":""},{"location":"org.metaborg.meta.lang.template/trans/statix/module.stx/","title":"<code>module.stx</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/trans/statix/module.stx</p> <pre><code>module statix/module\n\nimports\n\n  statix/section/section\n  statix/name\n  statix/type\n  statix/symbol\n\nsignature // Declarations\n\n  sorts Module constructors\n    Module : ModuleName * list(ImpSection) * list(Section) -&gt; Module\n\n  sorts ModuleName constructors\n    Unparameterized : ModuleId                -&gt; ModuleName\n    Parameterized   : ModuleId * list(Symbol) -&gt; ModuleName\n\n  sorts ModuleId // Use module identifiers as-is.\n\nrules\n\n  moduleOK : scope * Module\n  moduleOK(sGlobal, Module(name, importSections, sections)) :- {sMod}\n    new sMod, sMod -P-&gt; sGlobal,\n    declareModule(sGlobal, sMod, name),\n    moduleNameOK(sMod, name),\n    importSectionsOK(sMod, importSections),\n    sectionsOK(sMod, sections).\n\n  moduleNameOK : scope * ModuleName\n  moduleNameOK(s, Parameterized(_, symbols)) :- typesOfSymbols(s, symbols) == _.\n  moduleNameOK(s, _).\n\nrules\n\n  declareModule : scope * scope * ModuleName\n  declareModule(sGlobal, sMod, name) :- {id}\n    idOfModuleName(name) == id,\n    sGlobal -&gt; Module{id} with typeOfDecl MOD(sMod),\n    Module{id} in sGlobal |-&gt; [(_, (_))] | error $[Duplicate definition of module [id]]@id.\n\n  typeOfModule : scope * ModuleName -&gt; TYPE\n  typeOfModule(s, name) = Tmod :- {id paths}\n    idOfModuleName(name) == id,\n    typeOfDecl of Module{id} in s |-&gt; paths,\n    resolveModules(id, paths, NON_EMPTY()) == Tmod.\n\n  resolveModules : ModuleId * list((path * (occurrence * TYPE))) * EMPTINESS -&gt; TYPE\n  resolveModules(id, [(_, (Module{id'}, Tmod))|paths], _) = Tmod :-\n    @id.ref += id',\n    resolveModules(id, paths, MAYBE_EMPTY()) == Tmod.\n  resolveModules(id, [], NON_EMPTY())   = _ :- false | error $[Module [id] is not defined]@id.\n  resolveModules(id, [], MAYBE_EMPTY()) = _.\n\n  idOfModuleName : ModuleName -&gt; ModuleId\n  idOfModuleName(Unparameterized(id))  = id.\n  idOfModuleName(Parameterized(id, _)) = id.\n\nsignature // Imports\n\n  sorts ImpSection constructors\n    Imports : list(Import) -&gt; ImpSection\n\n  sorts Import constructors\n    Module : ModuleName -&gt; Import\n\nrules\n\n  importSectionOK : scope * ImpSection\n  importSectionOK(s, Imports(imports)) :- importsOK(s, imports).\n  importSectionsOK maps importSectionOK(*, list(*))\n\n  importOK : scope * Import\n  importOK(s, Module(name)) :- {sMod}\n    typeOfModule(s, name) == MOD(sMod),\n    s -I-&gt; sMod.\n  importsOK maps importOK(*, list(*))\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/trans/statix/module.stx/#modal-h2","title":"module.stx","text":""},{"location":"org.metaborg.meta.lang.template/trans/statix/name.stx/","title":"<code>name.stx</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/trans/statix/name.stx</p> <pre><code>module statix/name\n\nimports\n\n  statix/module\n\nsignature\n\n  namespaces\n    Module      : ModuleId\n    Sort        : string\n    Constructor : string\n    Label       : string\n\n  name-resolution\n    labels P I\n    resolve Module      filter P* min $ &lt; P\n    resolve Sort        filter P* | (P* I)\n    resolve Constructor filter P* | (P* I)\n    resolve Label       filter e min\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/trans/statix/name.stx/#modal-h2","title":"name.stx","text":""},{"location":"org.metaborg.meta.lang.template/trans/statix/production.stx/","title":"<code>production.stx</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/trans/statix/production.stx</p> <pre><code>module statix/production\n\nimports\n\n  statix/type\n  statix/attribute\n  statix/sort_cons\n\nrules\n\n  injectionProductionOK: TYPE * Attributes * SymbolDef\n  // Disabled for now: produces spurious errors in some cases.\n  //injectionProductionOK(PROD([_, _|_], SORT(_)), attrs, loc) :-\n  //  try { hasAttribute(Reject(), attrs) == TRUE() } | warning $[Missing constructor name: the generated pretty printer might not work properly] @loc.\n  injectionProductionOK(_, _, _).\n\n  // TODO: error: Missing bracket attribute or constructor name\n  // - LHS must be a single sort (injection)\n  // - RHS must be in the form of '(' Sort ')'\n  // - attributes must NOT contain Bracket() nor Reject()\n\n  // TODO: warning: Illegal use of the {bracket} attribute\n  // - HS must be a single sort (injection)\n  // - RHS must NOT be in the form of '(' Sort ')'\n  // - attributes must contain Bracket()\n  // - attributes must NOT contain Reject()\n\n  // TODO: warning: Illegal use of the {bracket} attribute\n  // - LHS must be a sort + constructor (not an injection)\n  // - attributes must contain Bracket()\n  // - attributes must NOT contain Reject()\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/trans/statix/production.stx/#modal-h2","title":"production.stx","text":""},{"location":"org.metaborg.meta.lang.template/trans/statix/sort.stx/","title":"<code>sort.stx</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/trans/statix/sort.stx</p> <pre><code>module statix/sort\n\nimports\n\n  statix/name\n  statix/type\n  statix/util\n\nsignature\n\n  sorts SORT_KIND constructors\n    CONTEXTFREE :  SORT_KIND\n    LEXICAL     :  SORT_KIND\n    VAR         :  SORT_KIND\n\n  relations\n    kindOfSort : occurrence -&gt; SORT_KIND\n\nrules\n\n  declareSort : scope * string * SORT_KIND -&gt; TYPE\n  declareSort(s, name, kind) = Tsort :-\n    Tsort == SORT(Sort{name}),\n    s -&gt; Sort{name} with typeOfDecl Tsort and kindOfSort kind,\n    Sort{name} in s |-&gt; [(_, (_))] | error $[Sort [name] is already defined],\n    @name.type := Tsort.\n\n  typeOfSort : scope * string -&gt; TYPE\n  typeOfSort(s, name) = Tsort :- {paths}\n    typeOfDecl of Sort{name} in s |-&gt; paths,\n    resolveTypeOfSorts(name, paths, NON_EMPTY()) == Tsort,\n    @name.type := Tsort.\n\n  resolveTypeOfSorts : string * list((path * (occurrence * TYPE))) * EMPTINESS -&gt; TYPE\n  resolveTypeOfSorts(name, [(_, (Sort{name'}, Tsort))|paths], _) = Tsort :-\n    @name.ref += name',\n    resolveTypeOfSorts(name, paths, MAYBE_EMPTY()) == Tsort.\n  resolveTypeOfSorts(name, [], NON_EMPTY())   = _ :- false | error $[Sort [name] is not defined]@name.\n  resolveTypeOfSorts(name, [], MAYBE_EMPTY()) = _.\n\n  kindOfSort : scope * string -&gt; SORT_KIND\n  kindOfSort(s, name) = Tsort :- {paths}\n    kindOfSort of Sort{name} in s |-&gt; paths,\n    resolveKindOfSorts(name, paths, NON_EMPTY()) == Tsort,\n    @name.type := Tsort.\n\n  resolveKindOfSorts : string * list((path * (occurrence * SORT_KIND))) * EMPTINESS -&gt; SORT_KIND\n  resolveKindOfSorts(name, [(_, (Sort{name'}, Tsort))|paths], _) = Tsort :-\n    @name.ref += name',\n    resolveKindOfSorts(name, paths, MAYBE_EMPTY()) == Tsort.\n  resolveKindOfSorts(name, [], NON_EMPTY())   = _ :- false | error $[Sort [name] is not defined]@name.\n  resolveKindOfSorts(name, [], MAYBE_EMPTY()) = _.\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/trans/statix/sort.stx/#modal-h2","title":"sort.stx","text":""},{"location":"org.metaborg.meta.lang.template/trans/statix/sort_cons.stx/","title":"<code>sort_cons.stx</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/trans/statix/sort_cons.stx</p> <pre><code>module statix/sort_cons\n\nimports\n\n  statix/name\n  statix/type\n  statix/sort\n  statix/cons\n  statix/symbol\n  statix/util\n\nsignature\n\n  sorts SortCons constructors\n    SortCons : SymbolDef * Constructor -&gt; SortCons\n\n  sorts Constructor constructors\n    Constructor : string -&gt; Constructor\n\n  sorts SymbolDef constructors\n    SortDef          : string    -&gt; SymbolDef\n    SymbolDefCf      : SymbolDef -&gt; SymbolDef\n    SymbolDefLex     : SymbolDef -&gt; SymbolDef\n    SymbolDefVar     : SymbolDef -&gt; SymbolDef\n    SymbolDef_Symbol : Symbol    -&gt; SymbolDef\n\n  sorts SortConsRef constructors\n    SortConsRef : Symbol * Constructor -&gt; SortConsRef\n\nrules\n\n  declareSortCons: scope * list(TYPE) * SortCons -&gt; TYPE\n  declareSortCons(s, Tsymbols, SortCons(symbolDef, Constructor(constructorName))) = Tprod :- {Tsort}\n    typeOfSymbolDef(s, symbolDef) == Tsort,\n    declareConstructor(s, Tsymbols, Tsort, constructorName) == Tprod.\n\n  typeOfSymbolDef: scope * SymbolDef -&gt; TYPE\n  typeOfSymbolDef(s, SortDef(name))            = Tsort :- typeOfSort(s, name)           == Tsort.\n  typeOfSymbolDef(s, SymbolDefCf(symbolDef))   = T     :- typeOfSymbolDef(s, symbolDef) == T.\n  typeOfSymbolDef(s, SymbolDefLex(symbolDef))  = T     :- typeOfSymbolDef(s, symbolDef) == T.\n  typeOfSymbolDef(s, SymbolDefVar(symbolDef))  = T     :- typeOfSymbolDef(s, symbolDef) == T.\n  typeOfSymbolDef(s, SymbolDef_Symbol(symbol)) = T     :- typeOfSymbol(s, symbol)       == T.\n\n  typeOfSortConsRef: scope * SortConsRef -&gt; TYPE\n  typeOfSortConsRef(s, SortConsRef(symbol, Constructor(constructorName))) = Tprod :- {Tsort}\n    typeOfSymbol(s, symbol) == Tsort,\n    typeOfConstructorInSort(s, constructorName, Tsort) == Tprod.\n  typeOfSortConsRefs maps typeOfSortConsRef(*, list(*)) = list(*)\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/trans/statix/sort_cons.stx/#modal-h2","title":"sort_cons.stx","text":""},{"location":"org.metaborg.meta.lang.template/trans/statix/symbol.stx/","title":"<code>symbol.stx</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/trans/statix/symbol.stx</p> <pre><code>module statix/symbol\n\nimports\n\n  statix/type\n  statix/sort\n  statix/label\n\nsignature\n\n  sorts Symbol constructors\n    Sort              : string                -&gt; Symbol\n    ParameterizedSort : string * list(Symbol) -&gt; Symbol\n\n    Cf          : Symbol                -&gt; Symbol\n    Lex         : Symbol                -&gt; Symbol\n    Varsym      : Symbol                -&gt; Symbol\n    Label       : Label  * Symbol       -&gt; Symbol\n    Sequence    : Symbol * list(Symbol) -&gt; Symbol\n    Opt         : Symbol                -&gt; Symbol\n    Iter        : Symbol                -&gt; Symbol\n    IterStar    : Symbol                -&gt; Symbol\n    IterSep     : Symbol * Separator    -&gt; Symbol\n    IterStarSep : Symbol * Separator    -&gt; Symbol\n    Alt         : Symbol * Symbol       -&gt; Symbol\n\n    Layout    :              Symbol\n    CharClass : CharClass -&gt; Symbol\n    Lit       : string    -&gt; Symbol\n    CiLit     : string    -&gt; Symbol\n\n  sorts Separator CharClass\n\nrules\n\n  typeOfSymbol: scope * Symbol -&gt; TYPE\n\n  typeOfSymbol(s, sy@Sort(name)) = T :-\n    typeOfSort(s, name) == T,\n    @sy.type := T.\n  typeOfSymbol(s, sy@ParameterizedSort(name, symbols)) = T :-\n    typeOfSort(s, name) == T,\n    typesOfSymbols(s, symbols) == _,\n    @sy.type := T.\n\n  typeOfSymbol(s, Cf(symbol)) = T :-\n    typeOfSymbol(s, symbol) == T.\n  typeOfSymbol(s, Lex(symbol)) = T :-\n    typeOfSymbol(s, symbol) == T.\n  typeOfSymbol(s, Varsym(symbol)) = T :-\n    typeOfSymbol(s, symbol) == T.\n  typeOfSymbol(s, Label(label, symbol)) = T :-\n    labelOK(s, label),\n    typeOfSymbol(s, symbol)  == T.\n  typeOfSymbol(s, Sequence(symbol, symbols)) = SEQ(T, TS) :-\n    typeOfSymbol(s, symbol) == T,\n    typesOfSymbols(s, symbols) == TS.\n  typeOfSymbol(s, Opt(symbol)) = OPT(T) :-\n    typeOfSymbol(s, symbol) == T.\n  typeOfSymbol(s, Iter(symbol)) = ITER(T) :-\n    typeOfSymbol(s, symbol) == T.\n  typeOfSymbol(s, IterStar(symbol)) = ITER(T) :-\n    typeOfSymbol(s, symbol) == T.\n  typeOfSymbol(s, IterSep(symbol, _)) = ITER(T) :-\n    typeOfSymbol(s, symbol) == T.\n  typeOfSymbol(s, IterStarSep(symbol, _)) = ITER(T) :-\n    typeOfSymbol(s, symbol) == T.\n  typeOfSymbol(s, Alt(symbol1, symbol2)) = ALT(T1, T2) :-\n    typeOfSymbol(s, symbol1) == T1,\n    typeOfSymbol(s, symbol2) == T2.\n\n  typeOfSymbol(s, Layout())     = TERMINAL().\n  typeOfSymbol(s, CharClass(_)) = TERMINAL().\n  typeOfSymbol(s, Lit(_))       = TERMINAL().\n  typeOfSymbol(s, CiLit(_))     = TERMINAL().\n\n  typesOfSymbols maps typeOfSymbol(*, list(*)) = list(*)\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/trans/statix/symbol.stx/#modal-h2","title":"symbol.stx","text":""},{"location":"org.metaborg.meta.lang.template/trans/statix/type.stx/","title":"<code>type.stx</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/trans/statix/type.stx</p> <pre><code>module statix/type\n\nsignature\n\n  sorts TYPE constructors\n    SORT     : occurrence        -&gt; TYPE\n    SEQ      : TYPE * list(TYPE) -&gt; TYPE\n    OPT      : TYPE              -&gt; TYPE\n    ITER     : TYPE              -&gt; TYPE\n    ALT      : TYPE * TYPE       -&gt; TYPE\n    TERMINAL :                      TYPE\n    PROD     : list(TYPE) * TYPE -&gt; TYPE\n    INJ      : list(TYPE) * TYPE -&gt; TYPE\n    MOD      : scope             -&gt; TYPE\n\n  relations\n    typeOfDecl : occurrence -&gt; TYPE\n\nrules\n\n  onlyOneOf : TYPE * list((path * (occurrence * TYPE)))\n  onlyOneOf(ty, [(_, (_, ty ))|ps]) :- noneOf(ty, ps).\n  onlyOneOf(ty, [(_, (_, ty'))|ps]) :- onlyOneOf(ty, ps).\n  onlyOneOf(ty, [])                 :- false.\n\n  noneOf : TYPE * list((path * (occurrence * TYPE)))\n  noneOf(ty, [(_, (_, ty ))|ps]) :- false.\n  noneOf(ty, [(_, (_, ty'))|ps]) :- noneOf(ty, ps).\n  noneOf(ty, [])                 :- true.\n\n  appendTypes : list(TYPE) * list(TYPE) -&gt; list(TYPE)\n  appendTypes([t|ts], types) = [t|appendTypes(ts, types)].\n  appendTypes([    ], types) = types.\n\n  flattenTypes : list(list(TYPE)) -&gt; list(TYPE)\n  flattenTypes([ts|tts]) = appendTypes(ts, flattenTypes(tts)).\n  flattenTypes([      ]) = [].\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/trans/statix/type.stx/#modal-h2","title":"type.stx","text":""},{"location":"org.metaborg.meta.lang.template/trans/statix/util.stx/","title":"<code>util.stx</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/trans/statix/util.stx</p> <pre><code>module statix/util\n\nsignature\n\n  sorts EMPTINESS constructors\n    NON_EMPTY   : EMPTINESS\n    MAYBE_EMPTY : EMPTINESS\n\nsignature\n\n  sorts BOOL constructors\n    TRUE  : BOOL\n    FALSE : BOOL\n\nrules\n\n  bAnd: BOOL * BOOL    -&gt; BOOL\n  bAnd(TRUE(), TRUE() ) = TRUE().\n  bAnd(_     , _      ) = FALSE().\n\n  bOr: BOOL  * BOOL    -&gt; BOOL\n  bOr(FALSE(), FALSE()) = FALSE().\n  bOr(_      , _      ) = TRUE().\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/trans/statix/util.stx/#modal-h2","title":"util.stx","text":""},{"location":"org.metaborg.meta.lang.template/trans/statix/section/grammar.stx/","title":"<code>grammar.stx</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/trans/statix/section/grammar.stx</p> <pre><code>module statix/section/grammar\n\nimports\n\n  statix/section/section\n\nsignature\n\n  sorts Grammar\n\n  constructors\n    SDFSection : Grammar -&gt; Section\n\nrules\n\n  grammarOK: scope * Grammar\n\n  sectionOK(s, SDFSection(grammar)) :- grammarOK(s, grammar).\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/trans/statix/section/grammar.stx/#modal-h2","title":"grammar.stx","text":""},{"location":"org.metaborg.meta.lang.template/trans/statix/section/priority.stx/","title":"<code>priority.stx</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/trans/statix/section/priority.stx</p> <pre><code>module statix/section/priority\n\nimports\n\n  statix/section/grammar\n  statix/section/syntax\n  statix/sort_cons\n\nsignature\n\n  constructors\n    Priorities             : list(Priority) -&gt; Grammar\n    LexicalPriorities      : list(Priority) -&gt; Grammar\n    ContextFreePriorities  : list(Priority) -&gt; Grammar\n\n  sorts Priority constructors\n    Chain : list(Group)                   -&gt; Priority\n    Assoc : Group * Associativity * Group -&gt; Priority\n\n  sorts Group constructors\n    WithArguments  : Group * ArgumentIndicator                -&gt; Group\n    NonTransitive  : Group                                    -&gt; Group\n    SimpleGroup    : PriorityProduction                       -&gt; Group\n    ProdsGroup     : list(PriorityProduction)                 -&gt; Group\n    AssocGroup     : Associativity * list(PriorityProduction) -&gt; Group\n    SimpleRefGroup : SortConsRef                              -&gt; Group\n    ProdsRefGroup  : list(SortConsRef)                        -&gt; Group\n    AssocRefGroup  : Associativity * list(SortConsRef)        -&gt; Group\n\n  sorts PriorityProduction constructors\n    PriorityProduction_SdfProduction : SdfProduction -&gt; PriorityProduction\n    PriorityProduction_Production    : Production    -&gt; PriorityProduction\n\n  sorts ArgumentIndicator Associativity\n\nrules\n\n  grammarOK(s, Priorities(priorities))            :- prioritiesOK(s, priorities).\n  grammarOK(s, LexicalPriorities(priorities))     :- prioritiesOK(s, priorities).\n  grammarOK(s, ContextFreePriorities(priorities)) :- prioritiesOK(s, priorities).\n\n  priorityOK: scope * Priority\n  priorityOK(s, Chain(groups)) :-\n    groupsOK(s, groups).\n  priorityOK(s, Assoc(group1, _, group2)) :-\n    groupOK(s, group1),\n    groupOK(s, group2).\n  prioritiesOK maps priorityOK(*, list(*))\n\n  groupOK: scope * Group\n  groupOK(s, WithArguments(group, _))            :- groupOK(s, group).\n  groupOK(s, NonTransitive(group))               :- groupOK(s, group).\n  groupOK(s, SimpleGroup(priorityProduction))    :- priorityProductionOK(s, priorityProduction).\n  groupOK(s, ProdsGroup(priorityProductions))    :- priorityProductionsOK(s, priorityProductions).\n  groupOK(s, AssocGroup(_, priorityProductions)) :- priorityProductionsOK(s, priorityProductions).\n  groupOK(s, SimpleRefGroup(sortConsRef))        :- typeOfSortConsRef(s, sortConsRef) == _.\n  groupOK(s, ProdsRefGroup(sortConsRefs))        :- typeOfSortConsRefs(s, sortConsRefs) == _.\n  groupOK(s, AssocRefGroup(_, sortConsRefs))     :- typeOfSortConsRefs(s, sortConsRefs) == _.\n  groupsOK maps groupOK(*, list(*))\n\n  priorityProductionOK: scope * PriorityProduction\n  // TODO: these should not declare new productions, but instead should be checked against existing ones?\n  priorityProductionOK(s, PriorityProduction_SdfProduction(sdfProduction)) :- typeOfSdfProduction(s, sdfProduction) == _.\n  priorityProductionOK(s, PriorityProduction_Production(production))       :- productionOK(s, production).\n  priorityProductionsOK maps priorityProductionOK(*, list(*))\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/trans/statix/section/priority.stx/#modal-h2","title":"priority.stx","text":""},{"location":"org.metaborg.meta.lang.template/trans/statix/section/restriction.stx/","title":"<code>restriction.stx</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/trans/statix/section/restriction.stx</p> <pre><code>module statix/section/restriction\n\nimports\n\n  statix/section/grammar\n  statix/symbol\n\nsignature\n\n  constructors\n    Restrictions            : list(Restriction) -&gt; Grammar\n    LexicalRestrictions     : list(Restriction) -&gt; Grammar\n    ContextFreeRestrictions : list(Restriction) -&gt; Grammar\n\n  sorts Restriction constructors\n    Follow : list(Symbol) * Lookaheads -&gt; Restriction\n\n  sorts Lookaheads\n\nrules\n\n  grammarOK(s, Restrictions(restrictions))            :- restrictionsOK(s, restrictions).\n  grammarOK(s, LexicalRestrictions(restrictions))     :- restrictionsOK(s, restrictions).\n  grammarOK(s, ContextFreeRestrictions(restrictions)) :- restrictionsOK(s, restrictions).\n\n  restrictionOK: scope * Restriction\n  restrictionOK(s, Follow(symbols, _)) :- typesOfSymbols(s, symbols) == _.\n  restrictionsOK maps restrictionOK(*, list(*))\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/trans/statix/section/restriction.stx/#modal-h2","title":"restriction.stx","text":""},{"location":"org.metaborg.meta.lang.template/trans/statix/section/section.stx/","title":"<code>section.stx</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/trans/statix/section/section.stx</p> <pre><code>module statix/section/section\n\nsignature\n\n  sorts Section\n\nrules\n\n  sectionOK: scope * Section\n  sectionsOK maps sectionOK(*, list(*))\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/trans/statix/section/section.stx/#modal-h2","title":"section.stx","text":""},{"location":"org.metaborg.meta.lang.template/trans/statix/section/sort.stx/","title":"<code>sort.stx</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/trans/statix/section/sort.stx</p> <pre><code>module statix/section/sort\n\nimports\n\n  statix/section/grammar\n  statix/sort\n\nsignature\n\n  constructors\n    Sorts : list(DeclSymbol) -&gt; Grammar\n\n  sorts DeclSymbol constructors\n    DeclSort    : string -&gt; DeclSymbol\n    DeclSortLex : string -&gt; DeclSymbol\n    DeclSortVar : string -&gt; DeclSymbol\n\nrules\n\n  grammarOK(s, Sorts(declSymbols)) :- declSymbolsOK(s, declSymbols).\n\n  declSymbolOK: scope * DeclSymbol\n  declSymbolOK(s, DeclSort(name))    :- declareSort(s, name, CONTEXTFREE()) == _.\n  declSymbolOK(s, DeclSortLex(name)) :- declareSort(s, name, LEXICAL()) == _.\n  declSymbolOK(s, DeclSortVar(name)) :- declareSort(s, name, VAR()) == _.\n  declSymbolsOK maps declSymbolOK(*, list(*))\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/trans/statix/section/sort.stx/#modal-h2","title":"sort.stx","text":""},{"location":"org.metaborg.meta.lang.template/trans/statix/section/start_symbol.stx/","title":"<code>start_symbol.stx</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/trans/statix/section/start_symbol.stx</p> <pre><code>module statix/section/start_symbol\n\nimports\n\n  statix/section/grammar\n  statix/symbol\n\nsignature\n\n  constructors\n    KernelStartSymbols      : list(Symbol) -&gt; Grammar\n    LexicalStartSymbols     : list(Symbol) -&gt; Grammar\n    ContextFreeStartSymbols : list(Symbol) -&gt; Grammar\n\nrules\n\n  grammarOK(s, KernelStartSymbols(symbols))      :- typesOfSymbols(s, symbols) == _.\n  grammarOK(s, LexicalStartSymbols(symbols))     :- typesOfSymbols(s, symbols) == _.\n  grammarOK(s, ContextFreeStartSymbols(symbols)) :- typesOfSymbols(s, symbols) == _.\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/trans/statix/section/start_symbol.stx/#modal-h2","title":"start_symbol.stx","text":""},{"location":"org.metaborg.meta.lang.template/trans/statix/section/syntax.stx/","title":"<code>syntax.stx</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/trans/statix/section/syntax.stx</p> <pre><code>module statix/section/syntax\n\nimports\n\n  statix/section/grammar\n  statix/section/template\n  statix/name\n  statix/type\n  statix/sort_cons\n  statix/symbol\n  statix/production\n  statix/attribute\n\nsignature\n\n  constructors\n    Syntax                 : list(Production)        -&gt; Grammar\n    Lexical                : list(Production)        -&gt; Grammar\n    Contextfree            : list(Production)        -&gt; Grammar\n    Variables              : list(Production)        -&gt; Grammar\n    LexVariables           : list(Production)        -&gt; Grammar\n    VariablesProductive    : list(SdfProduction)     -&gt; Grammar\n    LexVariablesProductive : list(SdfProduction)     -&gt; Grammar\n    Kernel                 : list(SdfProduction)     -&gt; Grammar\n    LexicalSyntax          : list(SdfProduction)     -&gt; Grammar\n    ContextFreeSyntax      : list(GeneralProduction) -&gt; Grammar\n\n  sorts Production constructors // Kernel-style productions\n    Prod : list(Symbol) * Symbol * Attributes -&gt; Production\n\n  sorts GeneralProduction constructors // General productions (explicated injection)\n    GeneralProduction_SdfProduction      : SdfProduction      -&gt; GeneralProduction\n    GeneralProduction_TemplateProduction : TemplateProduction -&gt; GeneralProduction\n\n  sorts SdfProduction constructors // SDF2-style productions\n    SdfProduction         : SymbolDef * RHS * Attributes -&gt; SdfProduction\n    SdfProductionWithCons : SortCons  * RHS * Attributes -&gt; SdfProduction\n\n  sorts RHS constructors\n    Rhs : list(Symbol) -&gt; RHS\n\nrules\n\n  grammarOK(s, Syntax(productions))                    :- productionsOK(s, productions).\n  grammarOK(s, Lexical(productions))                   :- productionsOK(s, productions).\n  grammarOK(s, Contextfree(productions))               :- productionsOK(s, productions).\n  grammarOK(s, Variables(productions))                 :- productionsOK(s, productions).\n  grammarOK(s, LexVariables(productions))              :- productionsOK(s, productions).\n  grammarOK(s, VariablesProductive(sdfProductions))    :- typeOfSdfProductions(s, sdfProductions) == _.\n  grammarOK(s, LexVariablesProductive(sdfProductions)) :- typeOfSdfProductions(s, sdfProductions) == _.\n  grammarOK(s, Kernel(sdfProductions))                 :- typeOfSdfProductions(s, sdfProductions) == _.\n  grammarOK(s, LexicalSyntax(sdfProductions))          :- typeOfSdfProductions(s, sdfProductions) == _.\n  grammarOK(s, ContextFreeSyntax(generalProductions))  :- generalProductionsOK(s, generalProductions).\n\n  productionOK: scope * Production\n  productionOK(s, Prod(symbols, symbol, _)) :- {sProd}\n    new sProd, sProd -P-&gt; s,\n    typesOfSymbols(sProd, symbols) == _,\n    typeOfSymbol(sProd, symbol) == _.\n  productionsOK maps productionOK(*, list(*))\n\n  generalProductionOK: scope * GeneralProduction\n  generalProductionOK(s, GeneralProduction_SdfProduction(sdfProduction))           :-\n    typeOfSdfProduction(s, sdfProduction) == _.\n  generalProductionOK(s, GeneralProduction_TemplateProduction(templateProduction)) :-\n    typeOfTemplateProduction(s, templateProduction) == _.\n  generalProductionsOK maps generalProductionOK(*, list(*))\n\n  typeOfSdfProduction: scope * SdfProduction -&gt; TYPE\n  typeOfSdfProduction(s, SdfProduction(symbolDef, rhs@Rhs(symbols), attrs)) = Tprod :- {sProd Tsymbols Tsort}\n    typeOfSymbolDef(s, symbolDef) == Tsort,\n    new sProd, sProd -P-&gt; s,\n    typesOfSymbols(sProd, symbols) == Tsymbols,\n    Tprod == INJ(Tsymbols, Tsort),\n    injectionProductionOK(Tprod, attrs, symbolDef),\n    @rhs.type := Tprod.\n  typeOfSdfProduction(s, SdfProductionWithCons(sortCons, rhs@Rhs(symbols), _)) = Tprod :- {sProd Tsymbols Tsort}\n    declareSortCons(s, Tsymbols, sortCons) == Tprod,\n    new sProd, sProd -P-&gt; s,\n    typesOfSymbols(sProd, symbols) == Tsymbols,\n    @rhs.type := Tprod.\n  typeOfSdfProductions maps typeOfSdfProduction(*, list(*)) = list(*)\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/trans/statix/section/syntax.stx/#modal-h2","title":"syntax.stx","text":""},{"location":"org.metaborg.meta.lang.template/trans/statix/section/template.stx/","title":"<code>template.stx</code>","text":"<p> pdmosses/sdf/org.metaborg.meta.lang.template/trans/statix/section/template.stx</p> <pre><code>module statix/section/template\n\nimports\n\n  statix/section/section\n  statix/name\n  statix/type\n  statix/sort_cons\n  statix/symbol\n  statix/production\n  statix/attribute\n\nsignature // Section\n\n  constructors\n    TemplateSection : list(TemplateProduction) -&gt; Section\n\n  sorts TemplateProduction constructors\n    TemplateProduction         : SymbolDef * Template * Attributes -&gt; TemplateProduction\n    TemplateProductionWithCons : SortCons  * Template * Attributes -&gt; TemplateProduction\n\n  sorts Template constructors\n    Template           : list(TemplateLine) -&gt; Template\n    TemplateSquare     : list(TemplateLine) -&gt; Template\n    SingleLineTemplate : list(TemplatePart) -&gt; Template\n\n  sorts TemplateLine constructors\n    Line : list(TemplatePart) -&gt; TemplateLine\n\n  sorts TemplatePart constructors\n    Angled       : Placeholder -&gt; TemplatePart\n    Squared      : Placeholder -&gt; TemplatePart\n    BreakAngled  :                TemplatePart\n    BreakSquared :                TemplatePart\n    String       : string      -&gt; TemplatePart\n    Escape       : string      -&gt; TemplatePart\n    Layout       : string      -&gt; TemplatePart\n\n  sorts Placeholder constructors\n    Placeholder : Symbol * PlaceholderOptions -&gt; Placeholder\n\n  sorts PlaceholderOptions\n\nrules\n\n  sectionOK(s, TemplateSection(templateProductions)) :- typeOfTemplateProductions(s, templateProductions) == _.\n\n  typeOfTemplateProduction: scope * TemplateProduction -&gt; TYPE\n  typeOfTemplateProduction(s, TemplateProduction(symbolDef, template, attrs)) = Tprod :- {sProd Tsymbols Tsort}\n    typeOfSymbolDef(s, symbolDef) == Tsort,\n    new sProd, sProd -P-&gt; s,\n    typeOfTemplate(sProd, template) == Tsymbols,\n    Tprod == INJ(Tsymbols, Tsort),\n    injectionProductionOK(Tprod, attrs, symbolDef),\n    @template.type := Tprod.\n  typeOfTemplateProduction(s, TemplateProductionWithCons(sortCons, template, _)) = Tprod :- {sProd Tsymbols Tsort}\n    declareSortCons(s, Tsymbols, sortCons) == Tprod,\n    new sProd, sProd -P-&gt; s,\n    typeOfTemplate(sProd, template) == Tsymbols,\n    @template.type := Tprod.\n  typeOfTemplateProductions maps typeOfTemplateProduction(*, list(*)) = list(*)\n\n  typeOfTemplate: scope * Template -&gt; list(TYPE)\n  typeOfTemplate(s, Template(lines))            = flattenTypes(typeOfTemplateLines(s, lines)).     /* Flatten nested list */\n  typeOfTemplate(s, TemplateSquare(lines))      = flattenTypes(typeOfTemplateLines(s, lines)).     /* Flatten nested list */\n  typeOfTemplate(s, SingleLineTemplate([p|ps])) = appendTypes(TmaybePart, Trest) /* Append maybe-list */ :-\n    maybeTypeOfTemplatePart(s, p) == TmaybePart,\n    typeOfTemplate(s, SingleLineTemplate(ps)) == Trest.\n  typeOfTemplate(s, SingleLineTemplate([])) = [].\n\n  // Returns nested lists of types, as a template has multiple lines, with multiple parts.\n  typeOfTemplateLines : scope * list(TemplateLine) -&gt; list(list(TYPE))\n  typeOfTemplateLines(s, [l|ls]) = [Tline|Tlines] :-\n    typeOfTemplateLine(s, l) == Tline,\n    typeOfTemplateLines(s, ls) == Tlines.\n  typeOfTemplateLines(s, [    ]) = [].\n\n  typeOfTemplateLine: scope * TemplateLine -&gt; list(TYPE)\n  typeOfTemplateLine(s, Line([p|ps])) = appendTypes(TmaybePart, Trest) /* Append maybe-list */ :-\n    maybeTypeOfTemplatePart(s, p) == TmaybePart,\n    typeOfTemplateLine(s, Line(ps)) == Trest.\n  typeOfTemplateLine(s, Line([    ])) = [].\n\n  // Emulate option type: returns list of one type for sorts, and empty list for others.\n  maybeTypeOfTemplatePart: scope * TemplatePart -&gt; list(TYPE)\n  maybeTypeOfTemplatePart(s, Angled(placeholder))  = [typeOfPlaceholder(s, placeholder)].\n  maybeTypeOfTemplatePart(s, Squared(placeholder)) = [typeOfPlaceholder(s, placeholder)].\n  maybeTypeOfTemplatePart(s, _)                    = [].\n\n  typeOfPlaceholder: scope * Placeholder -&gt; TYPE\n  typeOfPlaceholder(s, Placeholder(symbol, _)) = typeOfSymbol(s, symbol).\n\nsignature // Options\n\n  constructors\n    TemplateOptions : list(TemplateOption) -&gt; Section\n\n  sorts TemplateOption constructors\n    KeywordAttributes : SymbolDef * Attributes -&gt; TemplateOption\n\nrules\n\n  sectionOK(s, TemplateOptions(templateOptions)) :- templateOptionsOK(s, templateOptions).\n\n  templateOptionOK: scope * TemplateOption\n  templateOptionOK(s, KeywordAttributes(symbolDef, _)) :- typeOfSymbolDef(s, symbolDef) == _.\n  templateOptionOK(s, _).\n  templateOptionsOK maps templateOptionOK(*, list(*))\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.template/trans/statix/section/template.stx/#modal-h2","title":"template.stx","text":""}]}